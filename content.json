{"meta":{"title":"jonathan-fei.pro","subtitle":null,"description":"Stay hungry. Stay foolish.","author":"jonathan-fei","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-12-30T12:21:04.000Z","updated":"2017-12-30T12:21:51.399Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-30T12:23:01.000Z","updated":"2017-12-30T12:23:14.179Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL 触发器的使用简介【转发】","slug":"MySQL-触发器的使用简介【转发】","date":"2018-02-27T10:04:42.000Z","updated":"2018-02-27T10:12:18.208Z","comments":true,"path":"2018/02/27/MySQL-触发器的使用简介【转发】/","link":"","permalink":"http://yoursite.com/2018/02/27/MySQL-触发器的使用简介【转发】/","excerpt":"","text":"本想总结一下关于MySQL触发器的使用，但是之前某大神给我分享了两篇很不错的触发器学习文章，遗憾的是没有原文的链接地址，于是只能这样恬不知耻的转发到自己的博客，用于今后的学习以及分享出来。总计两篇，拿走不谢~ 第一篇 《触发器入门》MySQL 5.1包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 【创建触发器】 在MySQL中，创建触发器语法如下：CREATE TRIGGER trigger_name trigger_time trigger_eventON tbl_name FOR EACH ROW trigger_stmt 其中：trigger_name：标识触发器名称，用户自行指定；trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；tbl_name：标识建立触发器的表名，即在哪张表上建立触发器；trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句。 由此可见，可以建立6种触发器，即：BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE、AFTER INSERT、AFTER UPDATE、AFTER DELETE。另外有一个限制是不能同时在一个表上建立2个相同类型的触发器，因此在一个表上最多建立6个触发器。 【trigger_event 详解】 MySQL 除了对 INSERT、UPDATE、DELETE 基本操作进行定义外，还定义了 LOAD DATA 和 REPLACE 语句，这两种语句也能引起上述6中类型的触发器的触发。LOAD DATA 语句用于将一个文件装入到一个数据表中，相当与一系列的 INSERT 操作。REPLACE 语句一般来说和 INSERT 语句很像，只是在表中有 primary key 或 unique 索引时，如果插入的数据和原来 primary key 或 unique 索引一致时，会先删除原来的数据，然后增加一条新数据，也就是说，一条 REPLACE 语句有时候等价于一条 INSERT 语句，有时候等价于一条 DELETE 语句加上一条 INSERT 语句。因此： INSERT 型触发器：插入某一行时激活触发器，可能通过 INSERT、LOAD DATA、REPLACE 语句触发； UPDATE 型触发器：更改某一行时激活触发器，可能通过 UPDATE 语句触发； DELETE 型触发器：删除某一行时激活触发器，可能通过 DELETE、REPLACE 语句触发。 【BEGIN … END 详解】 在MySQL中，BEGIN … END 语句的语法为：BEGIN [statement_list]END其中，statement_list 代表一个或多个语句的列表，列表内的每条语句都必须用分号（;）来结尾。而在MySQL中，分号是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL可以开始执行了。因此，解释器遇到 statement_list 中的分号后就开始执行，然后会报出错误，因为没有找到和 BEGIN 匹配的 END。这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思），它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiter new_delemiter 可以设为1个或多个长度的符号，默认的是分号（;），我们可以把它修改为其他符号，如管道符： DELIMITER |在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了管道符，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。 【一个完整的创建触发器示例】 假设系统中有两个表：班级表 class(班级号 classID, 班内学生数 stuCount)学生表 student(学号 stuID, 所属班级号 classID)要创建触发器来使班级表中的班内学生数随着学生的添加自动更新，代码如下：DELIMITER |create trigger tri_stuInsert after inserton student for each rowbegin declare c int; set c = (select stuCount from class where classID=new.classID); update class set stuCount = c + 1 where classID = new.classID;end|DELIMITER ; 【变量详解】MySQL 中使用 DECLARE 来定义一局部变量，该变量只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头， 即其它语句之前，语法如下：DECLARE var_name[,…] type [DEFAULT value]其中：var_name 为变量名称，同 SQL 语句一样，变量名不区分大小写；type 为 MySQL 支持的任何数据类型；可以同时定义多个同类型的变量，用逗号隔开；变量初始值为 NULL，如果需要，可以使用 DEFAULT 子句提供默认值，值可以被指定为一个表达式。 对变量赋值采用 SET 语句，语法为：SET var_name = expr [,var_name = expr] … 【NEW 与 OLD 详解】 上述示例中使用了NEW关键字，和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL 中定义了 NEW 和 OLD，用来表示 触发器的所在表中，触发了触发器的那一行数据。具体地： 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据； 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据； 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。 【查看触发器】 和查看数据库（show databases;）查看表格（show tables;）一样，查看触发器的语法如下：SHOW TRIGGERS [FROM schema_name]; 其中，schema_name 即 Schema 的名称，在 MySQL 中 Schema 和 Database 是一样的，也就是说，可以指定数据库名，这样就不必先“USE database_name;”了。 【删除触发器】 和删除数据库、删除表格一样，删除触发器的语法如下：DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name 【触发器的执行顺序】 我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有：①如果 BEFORE 触发器执行失败，SQL 无法正确执行②SQL 执行失败时，AFTER 型触发器不会触发③AFTER 类型的触发器执行失败，SQL 会回滚 第二篇 《MySQL-触发器的使用和创建》【什么是触发器】 触发器（TRIGGER）是MySQL的数据库对象之一，从5.0.2版本开始支持。该对象与编程语言中的函数非常类似，都需要声明、执行等。但是触发器的执行不是由程序调用，也不是由手工启动，而是由事件来触发、激活从而实现执行。有点类似DOM中的事件。那么为什么要使用数据库对象触发器呢？在具体开发项目时，经常会遇到如下实例： 在学生表中拥有字段学生姓名，字段学生总数，每当添加一条学生信息时，学生的总数就必须同时更改。 在学生表中还会有学生姓名的缩写，学生住址等字段，添加学生信息时，往往需要检查电话、邮箱等格式是否正确。上面的例子使用触发器完成时具有这样的特点，需要在表发生改变时，自动进行一些处理。MySQL在触发DELETE/UPDATE/INSERT语句时就会自动执行所设置的操作，其他SQL语句则不会激活触发器。 【创建触发器】 使用帮助命令查看具体的语法：CREATE [DEFINER = { user | CURRENT_USER }] TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_body语法中trigger_name：触发器的名称，不能与已经存在的触发器重复；trigger_time：{ BEFORE | AFTER }，表示在事件之前或之后触发；trigger_event:：{ INSERT |UPDATE | DELETE }，触发该触发器的具体事件；tbl_name：该触发器作用在tbl_name上； 【创建简单触发器】 示例1，创建简单触发器 准备学生表和学生数目统计表123456789CREATE TABLE student_info ( stu_no INT(11) NOT NULL AUTO_INCREMENT, stu_name VARCHAR(255) DEFAULT NULL, PRIMARY KEY (stu_no));CREATE TABLE student_count ( student_count INT(11) DEFAULT 0);INSERT INTO student_count VALUES(0); 创建简单触发器，在向学生表INSERT数据时，学生数增加，DELETE学生时，学生数减少12345678CREATE TRIGGER trigger_student_count_insertAFTER INSERTON student_info FOR EACH ROWUPDATE student_count SET student_count=student_count+1;CREATE TRIGGER trigger_student_count_deleteAFTER DELETEON student_info FOR EACH ROWUPDATE student_count SET student_count=student_count-1; INSERT、DELETE数据，查看触发器是否正常工作12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; INSERT INTO student_info VALUES(NULL,'张明'),(NULL,'李明'),(NULL,'王明');Query OK, 3 rows affected (0.02 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM student_info;+--------+----------+| stu_no | stu_name |+--------+----------+| 1 | 张明 || 2 | 李明 || 3 | 王明 |+--------+----------+3 rows in set (0.00 sec)mysql&gt; SELECT * FROM student_count;+---------------+| student_count |+---------------+| 3 |+---------------+1 row in set (0.00 sec)mysql&gt; DELETE FROM student_info WHERE stu_name IN('张明','李明');Query OK, 2 rows affected (0.00 sec)mysql&gt; SELECT * FROM student_info;+--------+----------+| stu_no | stu_name |+--------+----------+| 3 | 王明 |+--------+----------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM student_count;+---------------+| student_count |+---------------+| 1 |+---------------+1 row in set (0.00 sec) 可以看到无论是INSERT还是DELETE学生，学生数目都是跟随着变化的。 【创建包含多条执行语句的触发器】 在trigger_body中可以执行多条SQL语句，此时的trigger_body需要使用BEGIN和END作为开始和结束的标志：12345678CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] TRIGGER trigger_name trigger_time trigger_eventON tbl_name FOR EACH ROWBEGINtrigger_statementEND; 示例2，创建包含多条执行语句的触发器依然沿用上面的例子中的表，对student_count表做如下变更：增加student_class字段表示具体年级的学生数，其中0表示全年级，1代表1年级……；同样学生表中也增加该字段。清空两个表中的所有数据。 删除上例中的两个触发器，初始化student_count表中数据，插入三条数据(0,0),(1,0),(2,0)表示全年级、一年级、二年级的初始人数都是0； 创建触发器，在INSERT时首先增加学生总人数，然后判断新增的学生是几年级的，再增加对应年级的学生总数：12345678910DELIMITER $$CREATE TRIGGER trigger_student_count_insertAFTER INSERTON student_info FOR EACH ROWBEGINUPDATE student_count SET student_count=student_count+1 WHERE student_class=0;UPDATE student_count SET student_count=student_count+1 WHERE student_class= NEW.student_class;END$$DELIMITER ; 创建触发器，在DELETE时首先减少学生总人数，然后判断删除的学生是几年级的，再减少对应年级的学生总数：12345678910DELIMITER $$CREATE TRIGGER trigger_student_count_deleteAFTER DELETEON student_info FOR EACH ROWBEGINUPDATE student_count SET student_count=student_count-1 WHERE student_class=0;UPDATE student_count SET student_count=student_count-1 WHERE student_class= OLD.student_class;END$$DELIMITER ; 向学生表中分别插入多条不同年级的学生信息，查看触发器是否起作用：1234567891011121314151617181920212223242526mysql&gt; INSERT INTO student_info VALUES(NULL,'AAA',1),(NULL,'BBB',1),(NULL,'CCC',2),(NULL,'DDD',2),(NULL,'ABB',1),(NULL,'ACC',1);Query OK, 6 rows affected (0.02 sec)Records: 6 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM student_info;+--------+----------+---------------+| stu_no | stu_name | student_class |+--------+----------+---------------+| 4 | AAA | 1 || 5 | BBB | 1 || 6 | CCC | 2 || 7 | DDD | 2 || 8 | ABB | 1 || 9 | ACC | 1 |+--------+----------+---------------+6 rows in set (0.00 sec)mysql&gt; SELECT * FROM student_count;+---------------+---------------+| student_count | student_class |+---------------+---------------+| 6 | 0 || 4 | 1 || 2 | 2 |+---------------+---------------+3 rows in set (0.00 sec) 可以看到，总共插入了6条数据，学生总数是6，1年级4个，2年级2个，trigger正确执行。 从学生表中分别删除多条不同年级的学生信息，查看触发器是否起作用：12345678910111213141516171819202122mysql&gt; DELETE FROM student_info WHERE stu_name LIKE 'A%';Query OK, 3 rows affected (0.02 sec)mysql&gt; SELECT * FROM student_info;+--------+----------+---------------+| stu_no | stu_name | student_class |+--------+----------+---------------+| 5 | BBB | 1 || 6 | CCC | 2 || 7 | DDD | 2 |+--------+----------+---------------+3 rows in set (0.00 sec)mysql&gt; SELECT * FROM student_count;+---------------+---------------+| student_count | student_class |+---------------+---------------+| 3 | 0 || 1 | 1 || 2 | 2 |+---------------+---------------+3 rows in set (0.00 sec) 从学生表中将姓名以A开头的学生信息删除，学生信息删除的同时，数量表也跟随变化。在上面的示例中，使用了三个新的关键字：DELIMITER、NEW、OLD，这三个关键字在官网上“触发器语法”一节中都有介绍，整理如下： 【DELIMITER】 使用BEGIN…END结构，可以定义一个执行多句SQL的触发器。在BEGIN语句块中，还可以使用其它的语法，例如条件语句和循环语句。在MySQL中，分号”;”标志着SQL语句的结束，但是在触发器要执行的SQL语句中使用到了”;”作为要执行SQL语句的结束标记，所以你需要重新定义结束标识符。重新定义结束标识符使用DELIMITER关键字，后面跟空格和重新定义的结束标识符。注意：该语句与其他语句不同的是不需要在语句末尾添加结束标志符，如DELIMITER的作用是将现有的结束标识符重新定义为，但是，此时由于习惯或是疏忽在末尾添加了”;”也就是” DELIMITER;”那么该语句的作用就变成了将符号”;”作为新的结束标志符。 【NEW和OLD】 NEW在触发器为INSERT事件类型时有效，表示当前正在插入的数据；同理，OLD在触发器类型为DELETE事件类型时有效，表示当前正在删除的数据。如上面的示例中，可以在触发器中使用NEW.student_class取得正在插入的学生信息中年级值，使用OLD.student_class取得正在删除的学生信息中的年级值。 【触发器的使用限制】 官网“触发器语法和示例” http://dev.mysql.com/doc/refman/5.6/en/trigger-syntax.html 触发器只能创建在永久表上，不能对临时表创建触发器； 触发器不能使用CALL语句调用具有返回值或使用了动态SQL的存储过程（存储过程可以使用OUT或INOUT参数返回给触发器返回值）。 触发器中不能使用开启或结束事务的语句段，比如，开始事务（START TRANSACTION）、提交事务（COMMIT）或是回滚事务（ROLLBACK），但是回滚到一个保存点（SAVEPOINT是允许的，因为回滚到保存点不会结束事务）； 外键不会激活触发器； 当使用基于行的复制时，从表上的触发器不会因操作主表中的数据而激活。当使用基于语句的复制时，从表上的触发器会被激活。参考 Section 17.4.1.34,“Replication and Triggers”； 触发器中不允许返回值，因此触发器中不能有返回语句，如果要立即停止一个触发器，应该使用LEAVE语句； 【触发器中的异常机制】 MySQL的触发器是按照BEFORE触发器、行操作、AFTER触发器的顺序执行的，其中任何一步发生错误都不会继续执行剩下的操作。如果是对事务表进行的操作，那么会整个作为一个事务被回滚，但是如果是对非事务表进行的操作，那么已经更新的记录将无法回滚，这也是设计触发器的时候需要注意的问题。【查看触发器】 可以通过执行SHOW TRIGGERS命令查看触发器，但是因为不能查询指定的触发器，所以每次都返回所有的触发器的信息，使用不方便。但是可以使用查询系统表information_schema.triggers的方式指定查询条件，查看指定的触发器信息。如：123mysql&gt; USE information_schema;Database changedmysql&gt; SELECT * FROM triggers WHERE trigger_name='trigger_student_count_insert'; 【删除触发器】 DROP TRIGGER trigger_name;","categories":[{"name":"-数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"触发器","slug":"触发器","permalink":"http://yoursite.com/tags/触发器/"},{"name":"trigger","slug":"trigger","permalink":"http://yoursite.com/tags/trigger/"}]},{"title":"Ruby string#unpack ","slug":"Ruby-string-unpack","date":"2018-02-26T03:04:55.000Z","updated":"2018-02-26T03:07:49.868Z","comments":true,"path":"2018/02/26/Ruby-string-unpack/","link":"","permalink":"http://yoursite.com/2018/02/26/Ruby-string-unpack/","excerpt":"","text":"在学习字符串压缩之前，需要了解一些基础知识。 1. 比特（bit）运算（1）比特（bit），台湾称为“位”，是计算机中最小的数据单位，每一个bit的值是0或者1。（2）字节（Byte）：8个二进制位构成一个字节，字节是存储空间的基本计量单位。1个字节可以存储一个英文字母或者半个汉字，也就是说一个汉字需要两个字节存储。（3）换算12345678# 二进制换算1Byte = 8bits1Byte = 2nibbles1nibble = 4bits#十进制换算1Byte（B）= 8bits（b）1KB = 1000bytes （4）基本术语 most significant bit ————- 最高有效位 least significant bit ————- 最低有效位 ASCII ———————————– 美国信息交换标准代码：在计算机中，所有的数据在存储和运算时都以二进制表示，比如汉字、字符、英文等。 hex ：十六进制； dec： 十进制； oct：八进制； bin：二进制 unpack： 解压； pack：压缩。 2. String unpackString unpack and Array pack.12345&gt; 'jonathan'.unpack('C*').map&#123;|i| i.to_s 2&#125;=&gt; [\"1101010\", \"1101111\", \"1101110\", \"1100001\", \"1110100\", \"1101000\", \"1100001\", \"1101110\"]&gt; 'jonathan'.unpack('B*')=&gt; [\"0110101001101111011011100110000101110100011010000110000101101110\"] 上面这个例子的意思是将&#39;jonathan&#39; 这个字符串的每个字符解压成二进制位。 12&gt; 'jonathan'.unpack('C*')=&gt; [106, 111, 110, 97, 116, 104, 97, 110] 上面例子是将&#39;jonathan&#39;这个字符串解压为十进制位。12345&gt; 'jonathan'.unpack('H*')=&gt; [\"6a6f6e617468616e\"]&gt; 'jonathan'.unpack('C*').map&#123;|i| i.to_s 16&#125;=&gt; [\"6a\", \"6f\", \"6e\", \"61\", \"74\", \"68\", \"61\", \"6e\"] 上面这个例子是将&#39;jonathan&#39; 这个字符串解压成16进制位。更过例子：12345678\"abc \\0\\0abc \\0\\0\".unpack('A6Z6') #=&gt; [\"abc\", \"abc \"]\"abc \\0\\0\".unpack('a3a3') #=&gt; [\"abc\", \" \\000\\000\"]\"abc \\0abc \\0\".unpack('Z*Z*') #=&gt; [\"abc \", \"abc \"]\"aa\".unpack('b8B8') #=&gt; [\"10000110\", \"01100001\"]\"aaa\".unpack('h2H2c') #=&gt; [\"16\", \"61\", 97]\"\\xfe\\xff\\xfe\\xff\".unpack('sS') #=&gt; [-2, 65534]\"now=20is\".unpack('M*') #=&gt; [\"now is\"]\"whole\".unpack('xax2aX2aX1aX2a') #=&gt; [\"h\", \"e\", \"l\", \"l\", \"o\"] 3. 参考资料ASCII百度百科Ruby pack unpackRuby中操作字符串的基本方法Packing &amp; Unpacking: A Guide to Reading Binary Data in Ruby","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"String unpack","slug":"String-unpack","permalink":"http://yoursite.com/tags/String-unpack/"}]},{"title":"重温注册与登录--学习笔记","slug":"重温注册与登录-学习笔记","date":"2018-02-25T07:12:49.000Z","updated":"2018-02-25T07:14:55.332Z","comments":true,"path":"2018/02/25/重温注册与登录-学习笔记/","link":"","permalink":"http://yoursite.com/2018/02/25/重温注册与登录-学习笔记/","excerpt":"","text":"最近把Ruby on Rails 教程重温了一遍，学习到了一些之前没注意到的知识。因此以笔记的形式记录下来，目的是为了梳理实作用户系统的步骤（大标题）与方法，以及一些豆知识，具体细节可以参考Ruby on Rails 教程。 一. 注册 豆知识：查看含有user的路径的命令 — rake routes | grep user 1. 建立模型，存储用户信息（1）模型user是单数，表示单个用户；表名users为复数，代表数据库存储了很多的用户信息。（2）rails c --sandbox rails的“沙盒”模式，退出后会撤销所做的所有操作。（3）创建与保存 user = User.new user.save 两步合成一步相当于user = User.create(..)（4）更新： user = User.first user.name = &quot;jonathan&quot; user.save 合成一步 相当于 user.update(:name =&gt; &quot;jonathan&quot;)关于更新用户属性值的写法有以下几种：123第一种写法. user.update(:name =&gt; \"joanthan\")第二种写法. user.update(name: \"joanthan\")第三种写法. user.update_attribute(:name, \"joanthan\") update 与 update_attribute 的区别：update会把user模型中的update_at栏位更新为当前时间；update_attribute 只更新要求更新的字段值。 2. 数据验证建立好user的模型，我们需要添加必要的数据验证。有存在性、长度（姓名长度等）、格式（邮箱格式）、唯一性。我们需要用到Active Record中的validate方法，以及正则表达式等来完成这些设置。 对于唯一性来讲，Active Record的设置后的数据唯一性无法保证数据库层的唯一性，比如用户用同一个账号同时注册的情况，解决方法是： 在数据层为需要进行唯一性设置的加上索引，并进行唯一性约束。 3.安全密码分为两步：（1）设置密码，并进行二次确认；（2）验证身份：获取用户提交的密码，哈希加密，然后与数据库存储的密码进行比较。（3）使用SSL进行加密通信防止数据被恶意用户拦截，确保传输层安全。 实现过程：使用has_secure_password方法实现条件：user模型中须有 password_digest字段具体细节：在user模型中调用has_secure_password方法时，会添加如下功能。A. password_digest存储密码的哈希值；B. 获得一对虚拟属性，password与password_confirmation；虚拟属性的意思为在model中有这两个属性，但是数据库中没有对应的列。C. 获得authenticate 方法，如果输入的密码值哈希后与数据库存储的密码哈希相同，返回对应的对象，否则返回true。 豆知识： （1）使用bcrypt计算密码哈希值 （2）!!会把结果转化成相应的boolean。例如!!user.authenticate(&quot;123456&quot;) （3）健壮参数：user_params params.require(:user).permit(:name, :email) 二.登录1. 会话（1）session是两台电脑之间的半永久性连接，使得用户在切换网页时能够记住用户状态；（2）Users资源使用数据库存储数据，session使用cookie；（3）Rails中提供session来实现临时会话；（4）会话不是模型，不能创建类型@user的实例变量。form_for(@user)会让表单向/users发起post请求；这里我们可以使用form_for(:session, url: login_path) 2. 验证用户身份豆知识：params[:session][:email] 是一个嵌套散列。123456user = User.find_by(email: params[:session][:email].downcase)user &amp;&amp; user.authenticate(params[:session][:password])意思为当且仅当通过邮箱查到一个用户且提交的密码和数据库的密码匹配有时习惯写成user.present? user.authenticate(params[:session][:password]) 3. 实现登录（1）临时会话会让用户登录，关闭浏览器后会关闭会话；（2）include SessionHelper引入模块；（3）session[:user_id] = user.id ，将session视为一个散列，user_id为键，user.id为值；（4）redirect_to user 返回的是 user_url(user)。 三. 高级登录使用cookie有会话劫持的风险，有四种途径盗取cookie信息 （1）使用包嗅探接活不安全网络中传输的cookie 。 =&gt; 使用SSL解决 （2）获取包含记忆令牌的数据库。=&gt; 数据库中不直接存储记忆令牌，而是哈希。 （3）使用跨站脚本攻击。=&gt; Rails会自动转移视图模板的内容。 （4）获取已登录用户的访问权。=&gt; 尽量降低其影响，通过加密存储。 SecureRandom.urlsafe_base64 会返回长度为22的随机字符串，每一个字符串有64种可能。 1. 持久会话实现步骤：（1）生成随机字符串，用户记忆令牌（remember_token）；（2）把令牌存入浏览器的cookie，并设置过期时间；（3）在数据库存储令牌摘要（remember_digest）；（4）在浏览器的cookie存储加密后的用户ID；（5）如果cookie中有用户ID，那么就用这个ID查找数据库的用户，并检查cookie中的记忆令牌和数据中的哈希摘要是否匹配。 创建有效令牌和摘要：（1）使用 User.new_token 创建一个新记忆令牌；（2）使用 User.digest生成摘要；（3）更新数据库中的摘要。 豆知识： self.remember_token = User.new_token,会把值赋给用户的remember_token属性；如果没有self,remember_token只是一个局部变量。 相关代码如下：12345678910111213141516171819# 返回指定字符串的哈希摘要 def digest(string) cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost BCrypt::Password.create(string, cost: cost) end #返回一个随机令牌（用于remember_token） def new_token SecureRandom.urlsafe_base64 endend#为了持久保持会话，在数据库中记住用户 def remember self.remember_token = User.new_token update_attribute(:remember_digest, User.digest(remember_token))end 2. 登录时记住登录状态（1）cookies方法和session方法一样，也将它视为一个散列；12cookies[:remember_token] = &#123; value: remember_token, expires: 20.years.from_now.utc&#125;=&gt; cookies.permanent[:remember_token] = remember_token （2）持久存储用户ID123cookies[:user_id] = user.id #已纯文本的格式存入cookie，这样不安全cookies.signed[:user_id] = user.id # 对cookie签名，存取浏览器前安全加密cookiecookies.permanent.signed[:user_id] = user.id # 持久保存用户ID （3）存储cookie后，用下列代码搜索用户1user = User.find_by(id: cookies.signed[:user_id]) A. cookies.signed[:user_id] 会自动解密用户ID；B. 使用bcrypt确定cookies[:remember_token] 与 remember_digest是否匹配 .1Bcrypt::Password.new(remember_digest).is_password?(remember_token) （4）知识补充：三元运算符123456789101112131415161718192021222324例子1：if boolean? do_one_thingelse do_other_thingend=&gt; boolean? ? do_one_thing : do_other_thing例子2：if boolean? var = fooelse var = barend =&gt; var = boolean? ? foo : bar例子3：def foo do_stuff boolean? ? \"bar\" : \"baz\"endRuby 函数的默认返回值是定义体中的最有一个表打式，所以foo方法的返回值会根据boolean？的结果而不同，不是“bar” 就是“baz” 我们写一个简单的脚本来做一个小试验：1234567print \"请输入x的值：\"x = gets.to_iprint \"请输入y的值：\"y = gets.to_iputs \"x &gt; y ? 1 : 2\" 四. 权限系统1. 必须先登录2. 只能编辑自己的资料3. 友好转向： 登录以后重定向到登录前的页面。4. 用户管理： 加入新字段（如admin）","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"注册与登录","slug":"注册与登录","permalink":"http://yoursite.com/tags/注册与登录/"},{"name":"session/cookie","slug":"session-cookie","permalink":"http://yoursite.com/tags/session-cookie/"}]},{"title":"简述Ransack","slug":"简述Ransack","date":"2018-02-23T10:16:56.000Z","updated":"2018-02-23T10:18:02.551Z","comments":true,"path":"2018/02/23/简述Ransack/","link":"","permalink":"http://yoursite.com/2018/02/23/简述Ransack/","excerpt":"","text":"一. Ransack 是什么？Ransack是rails中用来做搜索的一个gem。 二. Ransack 怎么用？12345#controller document class TblAccountsController &lt; ApplicationController @q = TblAccount.ransack([:q]) @player = TblAccount.result(distinct: true) end 12345# views document&lt;% search_form_for @q do |f| %&gt; &lt;%= f.search_field :account_cont %&gt; &lt;%= submit_tag \"搜索\", class: \"btn\" %&gt;&lt;% end %&gt; 这里只是简单的用法介绍，另外还有高级用法，这里不再赘述，具体用法可以参见https://github.com/activerecord-hackery/ransack/blob/master/README.md 三. Ransack 原理Ransack用来做模糊(LIKE)查询。当我们使用Ransack进行查询时，它会通过Active Record 执行sql语句，去搜索并且返回与输入字符相匹配的结果，查询日志代码如下：1SELECT `tbl_account`.* FROM `tbl_account` WHERE (`tbl_account`.`account` LIKE '%玩家%' LIKE '%joe%') 这样会查询中带有“joe”关键字的所有用户，我们可以直接将rails查询语句转化为sql语句，来弄清ransack查询的真相。123456 &gt;&gt; TblAccount.ransack(account_cont: \"jonathan\").result.to_sql # account为tbl_account这张表中的一个字段。 =&gt; SELECT `tbl_account`.* FROM `tbl_account` WHERE (`tbl_account`.`account` LIKE 'jonathan')相当于&gt;&gt; TblAccount.where(\"account like ?\", \"%jonathan%\")=&gt; SELECT `tbl_account`.* FROM `tbl_account` WHERE (account like 'jonathan') PS： 关于ransack中的cont以及其他搜索条件介绍，请参考这篇文章","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"Ransack","slug":"Ransack","permalink":"http://yoursite.com/tags/Ransack/"},{"name":"模糊查询","slug":"模糊查询","permalink":"http://yoursite.com/tags/模糊查询/"},{"name":"LIKE","slug":"LIKE","permalink":"http://yoursite.com/tags/LIKE/"}]},{"title":"精英的学习之法","slug":"寻常问题的精英解法-精英日课2","date":"2018-02-22T02:49:35.000Z","updated":"2018-02-22T14:43:42.143Z","comments":true,"path":"2018/02/22/寻常问题的精英解法-精英日课2/","link":"","permalink":"http://yoursite.com/2018/02/22/寻常问题的精英解法-精英日课2/","excerpt":"","text":"本文转载自得到APP万维刚《精英日课2》中的一篇名为“春节特刊-寻常问题的精英解法（3）”，里面谈到了“学习”这个让我们再熟悉不过的词，讲的很好，因此分享出来。 声明：支持正版阅读，万大大的文章写的很好，大家感兴趣的话可以下载得到app订阅《精英日课》专栏，相信会让你收获蛮多。 “学习”是一个我们常常提到的词，有人认为它很简单，有人觉得它很难，有人认为它等同于读书，有人感觉它无处不在；有人在大学毕业就停止了，有人决心要坚持一辈子。 查理·芒格说：我们只有学习了学习的方法之后才能成为高手。今天和明天，咱们就来总结回顾一下：高手该怎么学习。 1.为什么要学习 人身上的可遗传信息，把所有DNA信息加起来，大概只有1.6GB。而成年人大脑中可以存储的信息量，则是100TB。所以最理想的办法是只遗传最基本的本能，把绝大多数技能都留到后天慢慢学习。这 100TB 的脑容量就可以让你装下很多很多东西了，学习的潜能是巨大的。 正因为人是“生命2.0”，可以在一定程度上自己设计软件系统，人才是万物灵长。 所以我们千万不要像那些1.0的生物一样整天感慨遗传基因好不好，给你那么大的大脑是让你学习用的。 2.只在学习区学习人脑学习新技能，是发生在神经元这个层面的。因为练习一个动作而经常被一起触发的神经元，最后就会长在一起，整个网络结构长好了，就相当于一个技能长在了你的大脑之中。 心理学家把人对外界的感知分为三个区域，最里面第一层是“舒适区”，是我们熟悉的事物；最外面一层是“恐慌区”，是我们完全陌生的事物。“学习区”，是在舒适区和恐慌区之间，既有熟悉，又有新意。刻意练习的一个关键，就是要脱离舒适区，只在压力状态下做事。成长来自打击，技艺来自斗争。尝试、失败，再尝试、再失败，直到掌握为止，我们要的就是这样“有成效的失败”。 而且，我们不但应该在学习区练习，而且应该在学习区研究、工作和娱乐。关键的一点，就是你要敢于从舒适区往外走一步，但是还不能走得太远。面对这个世界你不能一味迎合，你要敢于任性地加入一点新东西，但是为了你自己的安全起见，也不要太新！ 不但学习新技能应该这样，平时工作也应该这样。心理学家契克森米哈赖说，想要达到心流状态，需要这个工作的难度和你的技能正好配得上。技能低工作难，你就会焦虑；技能高工作简单，你就会无聊。心流是工作难度稍微比你的技能高一点点，你历经一番忘我的挣扎把它完成。这样你不但做事做得有意思、感到时间过得特别快，而且还能不断提高水平。在这样的状态下学习和工作，需要高度集中注意力。 3.想记住，先忘记你可能会说，我是在学习区，学了，背了，但是啥也没记住，这不是白学了？ 其实，人的记忆有两个强度：存储强度（storage strength），和提取强度（retrieval strength）。 存储强度不会随时间减弱！我们每时每刻都在接收大量的信息，而其中的绝大部分都被大脑自动忽略了 —— 这些被忽略的不算。那些剩下来的，你主动希望记住的东西 —— 比如说一个人名，一个电话号码，一个英语单词 —— 一旦进入记忆，就永远在那里了。下次再见到它，它在你大脑里的存储强度会增强，但是哪怕你再也不见它了，它的存储强度也不会减弱。存储强度只增不减。 那么为什么我们会忘记一些东西呢？那是提取强度出了问题。如果没有复习，提取强度就随着时间慢慢减弱。 这其实很容易理解。比如现在让你回忆二十年前同学的音容笑貌，你肯定想不起来什么，但是如果你跟她突然见面，俩人一聊天，当初种种就呼啦一下全回来了。记忆一直都存在那里，只是不好提取了。心理学家说，提取强度是越用越高。每一次提取记忆，提取强度都会增加；而因为这个记忆在你脑子里又过了一遍，所以存储强度也增加了。 如此说来，考试就是最好的复习。拿本单词书从头到尾反复念 —— 这种效率很低，因为你没有提取动作！复习的时候你应该先考自己这个单词什么意思，实在想不起来了再去看答案。而最重要的是这个：提取的时候越困难，这个提取动作对两个强度的增加值就越大。 既然如此，最有效率的学习方法就不是天天复习，而是故意把它放在那里等几天，等到提取强度慢慢变弱了，我们已经有点“忘记”了，再搞一次测试式的复习。如此一来你不但用最少的时间学习，而且还能通过遗忘过滤掉一些不必要的信息。 以背单词为例，这就要求我们• 第一次复习是在一天之后；• 第二次就要拉长，比如说再等一周之后；• 然后是一个月之后；• 然后是几个月甚至更长时间。 而有实验证明，哪怕第一次复习是在两个月之后，你感觉什么都不记得了，其实还是能找到一点印象，这种学法还是有效的！ 所以要想记住，最好先忘了。 从这个角度讲，慢慢学才是好办法。这周学了一点就放下，下周接着学得先提取一下前面的记忆，这样多次提取，记忆就加深了很多。交叉着在同一时期内学习几门课程，比学完一门再学另一门的效果好得多。 4.慢慢来，比较快现在心理学认为人有两种“工作记忆”。“短期工作记忆”相当于计算机内存，是完成一项具体工作的时候大脑随时使用的记忆。“长期工作记忆”相当于硬盘，是我们平时的知识储备。 人的短期工作记忆能力非常有限，现在的公式是一般人只能同时考虑四个东西。这四个东西最好都是跟当前要解决的问题有关的，这就是为什么要专注。 所谓学习，就是把进入到大脑的短期工作记忆的内容强化吸收，写进长期工作记忆之中的过程。所谓创新，就是把长期工作记忆中的相关内容调出来，放在短期工作记忆里跟新信息形成配合的过程。 集中思维，就是在此时此刻的短期工作记忆里强化这个新信息。而发散思维，就是短期工作记忆和长期工作记忆之间的通道。 人脑不像计算机的存储器能瞬间记录信息，大脑是肉长的。这就好像砌墙，你有了砖头和水泥，总要再给点时间让水泥风干了，墙才能结实。 这就是为什么我们第一次学习新技能的时候总觉得很别扭，过段时间，哪怕是睡一觉或者隔一天不练，再拿起来感觉反而好多了。 这一小段“不练”的间隔期对大脑非常重要。就好比练举重，如果你每时每刻都举重，你的肌肉没有办法生长，总要停一段时间长肉。 我们学习各种技能，有时候会遇到一个短暂的“平台期”。比如我记得当年学开车，一开始进步神速，过了一段时间，就感觉有几天虽然一直在练，但是水平不但没提高反而还下降了，怎么开都别扭 —— 这就是平台期。这个平台期其实是大脑内部正在忙着建立新连接的时期，不是没有进步，后台正在重组！ 据此我们知道，学习知识并不是越快越好。复杂的技能需要时间间隔。 5.忘记的功夫修炼这个“忘记”的功夫，咱们得学学庄子。 我们看《庄子》书中人物一旦要去做个什么大事，总要花上好几天时间去做“忘记”的功夫。这种功夫大约分三步：• 正常状态，能听到外界的声音，考虑外界对自己的评价• 不听外界的声音了，只关注自己的内心冷认知对对错的判断• 忘记自己，不听冷认知的判断了，让热认知接手 这一套功夫，特别适合运动员和演员发挥。比如游泳，庄子就特别提到，如果这个人能忘记自己，忘记恐惧，他就能游得特别好。如果一个人游泳的时候总想着“自己”，可能连动作都不会做了。庄子这简直就是完美的无为状态。 6.无为的状态那么一位有学问的现代人，应该怎么达到无为的境界呢？ 孔子、老子、孟子和庄子，给我们提供了四种路径方法，每个人应该根据自己的性格喜好选择不同的方法，而且在人生的不同阶段，也可以使用不同的方法。 在学习任何技能的初期，我们应该用孔子的办法，勤学苦练，搞沉浸式的教育体验，争取习惯成自然。 具体做事的时候，尤其是要做那些能够影响别人的大事，我们应该参考老子的思想，不轻易干扰复杂系统。 培养艺术品位，提升道德水准，我们可以用孟子的办法，找到身上的闪光点作为种子，慢慢发展壮大。 如果面对一项压力巨大而又特别重要的工作，我们就应该学习庄子，忘记自我，让热认知引导我们发挥水平。 这些手段的确是互相矛盾的，但世界本来就充满矛盾。无为，本来就是一个悖论：你越想得到无为，你就越得不到无为。 这四派武功，你只有实践了，才知道那到底是什么境界。正所谓运用之妙，存乎一心。","categories":[],"tags":[]},{"title":"如何取出字符串中的汉字？","slug":"如何取出字符串中的汉字？","date":"2018-02-09T11:16:02.000Z","updated":"2018-02-09T11:20:17.627Z","comments":true,"path":"2018/02/09/如何取出字符串中的汉字？/","link":"","permalink":"http://yoursite.com/2018/02/09/如何取出字符串中的汉字？/","excerpt":"","text":"最近项目中需要实现取出用户的位置信息的小功能，但是数据表中location这个表示位置的字段的记录是这样的： 1\"&#123;\\\"y\\\":120, \\\"x\\\":30, \\\"loc\\\":\\\"浙江省杭州市\\\"&#125;\" 翻译成编程的意思为：取出字符串的汉字。实现过程如下： 1. 查找匹配中文字符的正则表达式（1） /[\\u4e00-\\u9fa5]/； 取出字符串中的所有汉字，并把每个汉字当做一个元素，并已数组的形式返回，即 [“浙”, “江” , “省”, “杭”, “州”, “ 市” ] 。（2）/\\p{Han}+/u；匹配字符串中的所有汉字，并把这一串汉字当做一个元素，以数组的形式返回， 即 [ “浙江省杭州市” ]。 2. 使用gsub方法Ruby中的gsub方法，它的作用是用指定的字符串置换原字符串中的某部分字符。代码片段：1234567891011if @player.present? @gamer = @player.first json.code 0 json.msg \"已找到该玩家\" json.playerMsg do json.location @gamer.location.gsub(/\\p&#123;Han&#125;+/u).first endelse json.code 1 json.msg \"玩家不存在\"end 其中 @gamer.location.gsub(/\\p{Han}+/u) 返回的是数组 [ “浙江省杭州市” ]， 如果只想得到里面的字符串，在其后加上first即可。这个用法与使用where条件查询颇为相似。（where查询后的结果返回的也是数组） 3. 踩过的坑在实现从字符串中取出汉字这个小功能中，一共产生两个思路：一是查找获取数组中元素的方法；二是如何将数组转化为字符串。但是都失败了，下面就来总结下踩过的坑。示例代码：12$ irb$ &gt; str = [\"123\"] #=&gt; [\"123\"] （1）Ruby中 获取数组的第一个元素1$ &gt; str[0] #=&gt; \"123\" PS： 在Rails中这样用会报错。undefined method &#39;[]&#39; （2）把数组中的元素变成一个字符串1$ &gt; str.join #=&gt; \"123\" PS： 在Rails中这样也会报错。undefined method &#39;join&#39; 总结： Ruby的编译环境(irb), 与Rails环境不可一概而论。","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"计算机学习资源小汇总","slug":"计算机学习资源小汇总","date":"2018-02-09T07:05:43.000Z","updated":"2018-02-20T05:50:44.241Z","comments":true,"path":"2018/02/09/计算机学习资源小汇总/","link":"","permalink":"http://yoursite.com/2018/02/09/计算机学习资源小汇总/","excerpt":"","text":"这篇文章统计了一些在日常学习中学到的知识点。不间断更新~ 进程与线程的简单解释 互联网协议入门（一） 互联网协议入门（二） 性能优化案例分析之一：软删除是慢查询的罪魁祸首? 性能优化案例分析之二：时间区域查询的性能优化","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/tags/网络基础/"}]},{"title":"N + 1 问题的解决方案","slug":"N-1-问题的解决方案","date":"2018-02-07T02:38:06.000Z","updated":"2018-02-08T14:41:59.815Z","comments":true,"path":"2018/02/07/N-1-问题的解决方案/","link":"","permalink":"http://yoursite.com/2018/02/07/N-1-问题的解决方案/","excerpt":"","text":"Rails中的Active Record的关联功能很强大，但是有时会产生N+1 SQL 查询问题。比如查看一篇文章下的很多评论就会产生N+1 问题。PS: 问题往往出现在一对多和多对多的关系中。参考资料： ihower实战圣经 解决思路如下： 1. 安装检测工具（1）gem &#39;rack-mini-profiler&#39; ，效能检测工具。安装后，网页上左上角会出现网页加载时间的提示。（2）gem &#39;bullet&#39;, group: &#39;development&#39;, N+1 query检测工具。使用流程可参考：bulldet，当你的代码存在N+1问题时，会出现例如下面的提示：1234USE eager loading detected Post =&gt; [:user] Add to your finder: :includes =&gt; [:user]Call stack 2. 使用 inclueds 关联（1）model 之间的关系1234567class User &lt; ApplicationRecord has_many :postsendclass Post &lt; ApplicationRecord belongs_to :userend （2）修改控制器中代码12345class PostsController &lt; ApplicationController def index posts = Post.includes(:user).page(params[:page]) endend 此时，就会观察到rails log中只会出现两条SQL查询语句,。12Comment Load (0.5ms) SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"post_id\" = ? [[\"post_id\", 1]] User Load (0.4ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" IN (4, 18, 2, 14, 13, 3, 12) N + 1 其实属于是慢查询的问题，下面就大体总结下解决慢查询问题及解决方法： N + 1 ——– ——–includes 大量数据 ———– find_each（或者 find_in_batches） 查询慢 ————– 加 索引 捞出所需字段 —— select 方法 计数快取 ———- Counter cache","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"N+1 SQL查询","slug":"N-1-SQL查询","permalink":"http://yoursite.com/tags/N-1-SQL查询/"},{"name":"rails","slug":"rails","permalink":"http://yoursite.com/tags/rails/"},{"name":"慢查询","slug":"慢查询","permalink":"http://yoursite.com/tags/慢查询/"}]},{"title":"使用 carrierwave 设置默认头像","slug":"使用-carrierwave设置默认头像","date":"2018-02-06T15:36:16.000Z","updated":"2018-02-08T14:41:34.328Z","comments":true,"path":"2018/02/06/使用-carrierwave设置默认头像/","link":"","permalink":"http://yoursite.com/2018/02/06/使用-carrierwave设置默认头像/","excerpt":"","text":"最近项目中需要实现头像上传功能的API接口，并且可以设置默认头像，这篇文章来大概总结一下具体的实现过程。 Rails中 实现图片上传最常用的是使用“gem carrierwave”。github 地址： carrierwave Step1 安装gem &quot;carrierwave&quot; gem &quot;mini_magick&quot; Step21rails g image uploader 这个命令会生成image_uploader.rb这个文件。之后关于图片的设置都需要在这个文件里设置。下面是我设置的配置文件。 12345678910111213141516171819202122232425262728293031 class ImageUploader &lt; CarrierWave::Uploader::Base include CarrierWave::MiniMagick storage :file def store_dir \"uploads/#&#123;model.class.to_s.underscore&#125;/#&#123;mounted_as&#125;/#&#123;model.id&#125;\" end# 设置图片大小，分为三个尺寸 process resize_to_fit: [800,800] version :thumb do process resize_to_fill: [200,200] end version :medium do process resize_to_fill: [400,400] end#设置图片的默认url地址，比如我要实现默认头像的设置，就会用到这个方法 def default_url(*args) \"/uploads/tbl_playerinfo/headimg/1/\" + [version_name, \"14563MHK40-13251.jpg\"].compact.join('_') end# 图片格式的设置 def extension_whitelist %w(jpg jpeg gif png) endend Step3设置model。table中的哪个字段存储图片就需要设置这个字段。1234class TblPlayerinfo &lt; ApplicationRecord # headimg 为存储用户头像的字段 mount_upload :headimg, ImageUploaderend Step4显示上传图片的url地址，代码如下：12345678910111213141516171819if @player.present? @gamer = @player.first json.code 0 json.msg \"已找到该玩家\" json.playerMsg do json.uid @gamer.userid json.name @gamer.nickname json.gold @gamer.gold json.online true json.sex @gamer.sex json.viptype @gamer.account.vip_type json.headimgurl @gamer.headimg_url json.score @gamer.score json.diamond @gamer.diamond endelse json.code 1 json.msg \"玩家不存在\"end 其中可以使用字段名加url后缀来直接显示图片的url地址。如headimg_url 总结：昨天一直想实现默认头像的功能，起初是在headimg这个字段设置默认值，但是捞出来的url总是错误的。后来仔细看了carrierwave的说明文档，才搞懂该如何设置默认的文件地址。教训：遇到问题要第一时间看官方文档和源代码，相比于在网络上寻找教程不仅可以提高自己的解决问题的效率，而且还能让自己养成看原始文档的好习惯。 补充：1234class TblPlayerinfo &lt; ApplicationRecord # headimg 为存储用户头像的字段 mount_upload :headimg, ImageUploaderend 其中headimg字段在数据库中的数据被记录为图片的名称。如果想要直接从数据库中直接获取完整的图片url地址，可以添加一个字段headimg2 用来代替headimg，然后headimg的值可以设置为服务器地址+headimg2, 例如12345678910111213if @player.update(:headimgxf =&gt; params[:image]) @player.update( :headimg =&gt; \"47.100.60.84\" + @player.headimgxf.to_s ) json.code 0 json.msg \"上传成功\" json.playerMsg do json.uid @player.userid json.name @player.nickname json.headimgurl @player.headimg endelse json.code 1 json.msg \"上传失败\"end 这样从数据库中捞取headimg字段的数据时就是完整的url地址了。","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"carrierwave","slug":"carrierwave","permalink":"http://yoursite.com/tags/carrierwave/"},{"name":"图片上传","slug":"图片上传","permalink":"http://yoursite.com/tags/图片上传/"}]},{"title":"Rails 中的数据查询方法","slug":"Rails-中的数据查询方法","date":"2018-02-06T09:30:51.000Z","updated":"2018-02-08T14:42:12.339Z","comments":true,"path":"2018/02/06/Rails-中的数据查询方法/","link":"","permalink":"http://yoursite.com/2018/02/06/Rails-中的数据查询方法/","excerpt":"","text":"Rails中的Acvtice Record使得我们不用写SQL语句就可以查询数据库中的数据。当使用Rails中的方法查询数据时，过程大体是这样的： 将查询选项转为sql语句 触发sql语句在数据库中查询 将查询结果实例化（变成对应的模型对象） 1– 查询单个对象（1）find方法find方法用于查询指定主键的对象；Author.find(1) （2） find_by方法find_by 方法会查询到符合条件的第一条记录Author.find_by(:name =&gt; &quot;鲁迅&quot;) 也可以写成Author.find_by name: &quot;鲁迅&quot; （3）take方法take方法会查询到一条记录，往往是数据表中的第一条记录。Author.take 2– 查询多个对象我们常常使用each方法，用来检索数据表中的记录。它的原理是会让Active Record 捞出整个数据表的数据，然后对每条记录创建模型对象，并把整个模型对象以数组形式保存在内存中。如果数据量很多的话，这样明显是行不通的。Rails有两种方法可以解决这个问题：（1）find_each工作原理：find_each方法每次检索一批记录，然后把每条记录实例化成模型对象传入块。默认每次检索1000条记录。123Player.find_each do |player| player.nameend a. 使用batch_size 来指定每次检索的记录总数123Player.find_each(batch_size: 5000) do |player| player.nameend b. 使用start 实现从起始点进行ID检索 ，比这个ID小的都不会取回。并且这个ID必须是主键。平常情况下较少用这个方法。1234# 检索id从10开始的作者姓名Player.find_each(start: 10) do |player| player.nameend c.使用finish 实现从起始点进行ID检索，比这个ID大的都不取回。与start类似。1234# 检索id为10000到20000的作者姓名Player.find_each(start: 10000, finish: 20000) do |player| player.nameend （2）find_in_batches工作原理：find_in_batches 方法每次检索一批记录，然后把每批记录实例化成模型数组传入块。用法和find_each 类似。 3.条件查询（1）数组条件中的占位符a. ?123$ Player.where(\"age &gt;= ?\", params[:age])或者$ Player.where(\"player.age &gt;= ?\", params[:age]) b. 字符如果条件中有很多变量，那么以下做法会更易于代码的阅读。1$ Player.where(\"age &gt;= :age AND saler &gt;= :wage_level_\", &#123; age: params[:age], wage_level: params[:wage_level]&#125;) （2）使用not 反向查询查询年龄在30岁以上的玩家123$ Player.where(\"diamond &gt; ?\", 30)也可以写成$ Player.where.not(\" diamond &lt;= ?\", 30) 4. 查询特定字段使用find、find_by、where方法时会返回table的全部字段，若想返回指定的字段可以使用select ，比如查询年龄大于20 的玩家名字。（1） select方法12345Player.select(:name).where(\"age &gt;= ?\", 30)查询名字和idPlayer.select(:userid, :name).where(\"age &gt;= ?\", 30)&amp;Player.select(\"userid, name\").where(\"age &gt;= ?\", 30) （2）pluck方法pluck 方法与select方法不同，select返回是一组对象模型，pluck方法是返回字段数组，因此在数据量很大的情况下使用pluck会好很多。123456Player.select(:nickname, :userid).map&#123; |u| [u.userid, u.nickname]&#125;相当于Player.pluck(:nickname, :userid)PS:map 的另一种写法Player.select(:userid).map(&amp;:userid) pluck方法会触发即时查询，个人理解为立即查询，所以当其他查询在pluck之前时，会执行成功；在pluck之后时，会查询失败。例如:123Player.pluck(:userid).limit(5) #=&gt; undefined method `limitPlayer.limit(5).pluck(:userid) #=&gt; [1], [2], [3], [4], [5] （3）ids方法ids方法会获得模型的主键，rails中模型主键默认为id，返回的是数组。1234567891011class Player &lt; ApplicationRecord self.primary_key = \"userid\"endPlayer.ids相当于Player.pluck(:userid)或Player.select(:id).map(&amp;:userid)或Player.select(:id).map&#123; |u| u.userid&#125; 5.关联查询（1） joins 方法示例代码：1234567class Player &lt; ApplicationRecord has_many :groups, class_name: \"GroupMsg\", foreign_key: \"userid\"endclass GroupMsg &lt; ApplicationRecord belongs_to :owner, class_name: \"Player\", foreign_key: \"userid\"end 1$ GroupMsg.joins(:owner) 这条语句的意思为所有属于某个用户的圈子作为一个GroupMsg对象返回。123$ GroupMsg.joins(:owner).where(:userid =&gt; 2)查询结果相当于$ Player.find_by(userid: 2).groups 1$ Player.joins(:groups) 这条语句的意思为查询所有创建了圈子的用户作为Player对象返回（可以简单理解为查询创建过圈子的用户）。如果一个用户创建了很多圈子，那么也会被重复列出。 （2）includes方法includes可以解决N+1queries问题，因为它可以及早加载关联。1Player.includes(:groups) 这条命令会取出所有的用户和所有的关联圈子。对应的SQL语句为123#=&gt; 假设只有五个用户select * from playersselect * from group_msgs where group_msgs.userid in (1,2,3,4,5) 1GroupMsg.includes(:owner) 这个命令会捞出所有的圈子和相关联的用户。对应的SQL语句为12select * from group_msgselect * from players where player.userid = [2,3,4]","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"find find_by","slug":"find-find-by","permalink":"http://yoursite.com/tags/find-find-by/"},{"name":"where","slug":"where","permalink":"http://yoursite.com/tags/where/"},{"name":"select","slug":"select","permalink":"http://yoursite.com/tags/select/"}]},{"title":"Ruby 基础--学习笔记","slug":"Ruby-基础-学习笔记","date":"2018-02-02T09:22:17.000Z","updated":"2018-02-09T02:15:24.875Z","comments":true,"path":"2018/02/02/Ruby-基础-学习笔记/","link":"","permalink":"http://yoursite.com/2018/02/02/Ruby-基础-学习笔记/","excerpt":"","text":"1。each、map与collect(1)each方法是典型的迭代器，它的作用是可以遍历数组中的所有元素，并对其进行处理，但不改变原数组的值，返回结果也是原数组的值。123456sum = 0a = [1,2,3,4,5]a.each do |item| sum+=itemendprint sum #=&gt; 15 123a = [1,2,3,4,5]a.each&#123; |item| item*2&#125; #=&gt; [1,2,3,4,5]a #=&gt; [1,2,3,4,5] (2) 使用map与collect方法会形成一个新数组，原数组的值不变。123456789a = [1,2,3,4,5]a.each&#123; |item| item*2&#125; #=&gt; [1,2,3,4,5]a #=&gt; [1,2,3,4,5]a.map&#123; |item| item*2&#125; #=&gt;[2,4,6,8,10]a #=&gt; [1,2,3,4,5]a.collect&#123; |item| item*2&#125; #=&gt; [2,4,6,8,10]a #=&gt; [1,2,3,4,5] (3)使用map!与collect!会形成一个新的数组，并改变原数组的值。123456a = [1,2,3,4,5]a.map!&#123; |item| item*2&#125; #=&gt; [2,4,6,8,10]a #=&gt; [2,4,6,8,10]a.collect!&#123; |item| item*2&#125; #=&gt; [2,4,6,8,10]a #=&gt; [2,4,6,8,10] 2。作用域（1）作用域门12345678910111213v1 = 1class Myclass v2 = 2 local_variables #=&gt; [:v2] def my_method v3 = 3 local_variables end local_variables #=&gt; [:v2]endobj = Myclass.newobj.my_method #=&gt; [:v3] 当进行类定义（关键字：class）、模块定义(module)、方法定义（def）会产生作用域。 （2）穿越作用域1234567891011var = \"scope\"class Myclass puts \"#&#123;var&#125;\" def my_method endend#=&gt; NameError: undefined local variable or method `var' for Myclass:Class得： 局部变量无法穿过Myclass的作用域 12345678910111213var = \"scope\"Myclass = Class.new do puts \"#&#123;var&#125; in the #&#123;self.class&#125;\" def my_method puts \"#&#123;var&#125;\" endend#=&gt; scope in the Class#=&gt; undefined local variable or method `my_var' for Myclass:Class (NameError)得：(1)通过方法调用可以让局部变量穿过Myclass的作用域;(2)局部变量var无法穿过my_method的作用域。 12345678910111213var = \"scope\"Myclass = Class.new do puts \"#&#123;var&#125; in the #&#123;self.class&#125;\" define_method :my_method do puts \"#&#123;var&#125; in the #&#123;self.class&#125;\" endendobj = Myclass.newobj.my_method#=&gt; scope in the Class#=&gt; scope in the Myclass 3. 单引号和多引号的区别Ruby中生成字符串有两种方式，单引号和双引号，其中单引号不被转义，多引号会被转义。12$ name = \"jonathan\" # =&gt; \"jonathan\"$ string = \"#&#123;name&#125;\" # =&gt; \"jonathan\" 12$ name = 'jonathan' # =&gt; \"jonathan\"$ string = '#&#123;name&#125;' # =&gt; \"\\#&#123;name&#125;\" 4. Symbol在散列中会常常用到符号（Symbol）。例如address = { :name =&gt; &quot;joanathan&quot;, :phone =&gt; &quot;123456&quot;} 其中:name :phone 就是符号。符号可以和字符串相互转换。12345name = :jonathan #=&gt; :jonathan等同于 name = :\"jonathan\"name1 = name.to_s #=&gt; \"jonathan\"name1.to_sym #=&gt; :jonathan 5. Ruby中的实例变量（1）Ruby中的对象包含实例变量，如果想要对象中的实例变量，需要调用对象的方法。示例代码：1234567891011121314class Person def name @name = \"Tim\" end def name=(vaule) @name = vaule end def kill @killer = name endend 下面就来做些小实验来验证需要调用方法才能访问对象中的实例变量。123tim = Person.newputs tim.name #=&gt; \"Tim\"puts tim.instance_variables #=&gt; [:@name] 此时没有调用kill方法，所以在tim这个对象调用instance_variables这个方法时没有@killer这个实例变量 1234tim = Person.newputs time.name #=&gt; \"Tim\"puts tim.killer #=&gt; \"Tim\"puts tim.instance_variables #=&gt; [:@name, :@killer] 12Tim = Person.newputs Time.name = \"Jonathan\" #=&gt; \"Jonathan\" 由此得知：Ruby如果想要访问对象中的实例变量或对其赋值，那么就需要调用对象的方法。（2）存取器存取器的定义为attr_accessor ，Ruby元编程中称为”类宏”,例如1234567891011121314class Person attr_accessor :nameend相当于class Person def name @name = \"Tim\" end def name=(vaule) @name = vaule endend 123tim = Person.newp tim.name = \"Jonathan\" #=&gt; \"Jonathan\"p tim.name #=&gt; \"Jonathan\" 123tim = Person.newp tim.name #=&gt; nil 因为@name的值为空p tim.name = \"Joanthan\" #=&gt; \"Jonathan\" 6. &lt;&lt; 符号在数组中，经常会用到 &lt;&lt;，示例代码:123ary = [1,2,3]ary &lt;&lt; 4ary = [1,2,3,4]","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"}]},{"title":"Ruby 中的 self","slug":"Ruby-中的-self","date":"2018-02-02T02:56:51.000Z","updated":"2018-02-08T14:44:35.298Z","comments":true,"path":"2018/02/02/Ruby-中的-self/","link":"","permalink":"http://yoursite.com/2018/02/02/Ruby-中的-self/","excerpt":"","text":"self 指的是当前对象。在调用方法时，分为两个步骤，查找方法和执行方法，调用方法的对象成为接收者，也就是当前对象。没有哪个对象可以一直充当当前对象的角色，并且，任何时刻，只有一个对象充当当前对象。 一. self 的含义1。在class关键字（类）内部，self指的是类本身。1234class Myclassputs selfend# Myclass 2。def 定义的方法内部，self指的是调用这个方法的对象（当前对象）1234567class Myclassdef my_method pust selfendend$ obj = Myclass.new #=&gt; #&lt;Myclass:0x007f90ee0e1830&gt;$ obj.method #=&gt; #&lt;Myclass:0x007f90ee0e1830&gt; 3。 self写在def关键字的后面，self指的是类本身12345678910class Myclassdef self.my_method puts selfendend$ obj = Myclass.new #=&gt; #&lt;Myclass:0x007fe83294de88&gt;$ obj.my_method #=&gt; NoMethodError: undefined method `my_method' for #&lt;Myclass:0x007fe83294de88&gt;$ Myclass.my_method #=&gt; Myclass 由此可见，当self出现在def关键字后面时，self指的是Myclass这个类，而非Myclass类的实例obj。 二. 显式self与隐式self《ruby元编程》中提到私有规则：私有方法只能通过阴性的接收者调用。另：当一个对象被创建时，那么它就获得了它所属类中的实例方法。1。 ruby中定义的方法不特殊说明时，默认为public方法。123456789101112131415161718192021222324class Apublic #可省略def method1 puts \"I am method1\" self.method2enddef method2 puts \"I am method2\"enddef method3puts \"I am method3\"method2endend$ obj = A.new$ obj.method1#=&gt; I am method1#=&gt; I am method2$ obj.method3#=&gt; I am method3#=&gt; I am method2 2。 private 定义私有方法123456789101112131415161718192021222324252627class Apublic #可省略def method1 puts \"I am method1\" self.method3enddef method2 puts \"I am method2\" method3endprivatedef method3puts \"I am method3\"endend$ obj = A.new$ obj.method3 #=&gt; private method `method3' called for #&lt;A:0x007fc1c9111f60&gt; (NoMethodError)$ obj.method1 #=&gt; private method `method3' called for #&lt;A:0x007f8f9e822230&gt; (NoMethodError)$ obj.method2#=&gt; I am method2#=&gt; I am method3 由此得知，调用私有方法时不能明确指定接收者是谁，也就是只有隐性的接受者才能调用私有方法。 三. 方法访问级别1。private 与 protected1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Fatherdef method_a puts \"I am METHOD A in #&#123;self.class&#125;\"enddef method_b puts \"I am METHOD B in #&#123;self.class&#125;\" self.method_c #self 可以省略endprotecteddef method_c puts \"I am METHOD C in #&#123;self.class&#125;\"endprivatedef method_secret puts \"I am method_secret in #&#123;self.class&#125;\"endendclass Son &lt; Fatherdef son_method_c method_cenddef son_method_d self.method_cenddef son_method_secret self.method_secretendend$ son = Son.new$ son.son_method_c #=&gt; I am METHOD C in Son$ son.son_method_d #=&gt; I am METHOD C in Son$ son.son_method_b#=&gt; I am METHOD B in Father#=&gt; I am METHOD C in Father$ son.method_c #=&gt; NoMethodError: protected method `method_c' called for$ son.method_secret #=&gt; NoMethodError: private method `method_secret' called for$ son.son_method_secret #=&gt; NoMethodError: private method `method_secret' called for$ father = Father.new$ father.method_c #=&gt; NoMethodError: protected method `method_c' called for 由此得知：（1）在调用protected和private级别的方法时，不管是同类的对象（father）还是子类的对象（son），都不能够对其直接调用；只能通过其他方式，比如在别的方法中引用。（2）ruby中的私有方法只能被阴性self调用；public方法和protected方法可被显示self和隐式self调用。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"self","slug":"self","permalink":"http://yoursite.com/tags/self/"}]},{"title":"Rails生成乱数ID的实现方法","slug":"Rails生成乱数ID的实现方法","date":"2018-01-08T12:40:02.000Z","updated":"2018-02-08T14:42:33.906Z","comments":true,"path":"2018/01/08/Rails生成乱数ID的实现方法/","link":"","permalink":"http://yoursite.com/2018/01/08/Rails生成乱数ID的实现方法/","excerpt":"","text":"在ROR网站开发中，当我们查询某笔资料时，一般情况下，网址是这样的，如下图： 这样做的缺陷很明显，就是用户可以通过网址猜到我们数据库中user的数据量。为了解决这个问题，我们可以通过把ID改成乱数ID的形式解决，就像下面这样： 实现过程如下： step1：model层的实现1- 为 user添加friendly_id 字段1$ rails g migration add_friendly_id_to_users 2- 在新生成的migration文件中，为friendly_id 添加唯一索引12add_column :users, :friendly_id, :stringadd_index :users, :friendly_id, :unique =&gt; true 1$ rake db:migrate 3- 修改user.model123456789before_validation :generate_friendly_id, on: :createdef to_param self.friendly_idenddef generate_friendly_id self.friendly_id ||= SecureRandom.uuidend 其中to_param Rails中自带的方法，我们在这里对它进行重新定义。之前的定义为，123def to_param self.idend 它的作用转换ID，例如user_path(current_user) 就相当于 user_path(current_user.to_param) ,也相当于 user_path(current_user.id)。 Step 2 controller层通常我们的users_controller.rb 会是这样123456789101112131415161718192021222324Class UsersController &lt; ApplicationController# 事例代码 before_action :find_user, only: [:show, :edit, :update] def show end def edit end def update if @user.update flash[:notice] = \"更新成功\" redirect_to users_path else render 'edit' end private def find_user @user = User.find(params[:id]) endend 我们对其中的 find_user这个方法 做如下修改 123def @user = User.find_by_friendly_id!(params[:id])end 到这里就可以实现乱数ID的显示了。 豆知识补充1- “||= ” 符号a ||= b 相当于 a = a || b ，它的意思为当a的值为nil时，将b的值付给a。例如 上面提到过的self.friendly_id ||= SecureRandom.uuid， 当self.friendly_id的值为空时，将SecureRandom.uuid赋值给它。","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"乱数ID","slug":"乱数ID","permalink":"http://yoursite.com/tags/乱数ID/"}]},{"title":"数据库的工作原理（一）","slug":"数据库的工作原理（一）","date":"2018-01-08T06:36:24.000Z","updated":"2018-01-08T06:38:09.407Z","comments":true,"path":"2018/01/08/数据库的工作原理（一）/","link":"","permalink":"http://yoursite.com/2018/01/08/数据库的工作原理（一）/","excerpt":"","text":"开始之前的说明：最近在学习数据库的相关知识，找到了一篇很好的学习文章，写的蛮深入，同样内容也很长，所以理解起来有些难度。为了让自己更好的理解数据库的工作原理，我把自己对这篇文章的理解，写成了这篇博客（共计三篇），旨在提高自己的学习效果。原文地址：http://blog.jobbole.com/100349/。 前言：在了解数据库是如何工作的内容之前，需要知道一些基本概念。在很久以前，开发人员需要把常用的算法和数据结构牢记于心，因为当时计算机的处理能力较差，无法承受对cpu的浪费。研究数据结构和算法的目的，或者说选择哪个数据结构和算法，是为了以更快的速度得到数据处理的结果。判断一个算法优劣的因素大体上有三个：（1）时间复杂度（2）算法的内存消耗（3）算法磁盘I/O消耗这里主要介绍时间复杂度的概念。PS：《数据库工作原理（一）》主要梳理相关的基础概念。 一、 时间复杂度时间复杂度指的是某个算法处理一定量数据所要消耗的时间。这个时间我们无法进行准确的计算，但是可以通过“某个算法处理一定量的数据需要多少次运算”来间接的判断算法的优劣。这里我们使用O(某函数)这样的方式来表示某个算法处理一定量的数据进行的运算次数，所需的运算次数即函数计算出的值，比如像下面这样。假设有1000000笔数据，各个算法的运算次数如下： O(1) 算法会消耗 1 次运算 O(log(n)) 算法会消耗 14 次运算 O(n) 算法会消耗 1,000,000 次运算 O(n*log(n)) 算法会消耗 14,000,000 次运算 O(n^2) 算法会消耗 1,000,000,000,000 次运算 这样我们就很容易得知，O（1）算法是我们首要选择的，O(n^2)是我们绝不会选择的算法。 了解了时间复杂度的概念以及如何表示时间复杂度后，接下来的内容会容易理解很多，比如： 一个好的哈希表会得到O(1)复杂度，这是最理想的状态 一个均衡的树会得到O(log(n))复杂度，其中n代表数据量，即要处理数据的数量大小 一个阵列会得到O(n)复杂度 最好的排序算法具有O(n*log(n))复杂度 糟糕的排序算法具有O(n^2)复杂度。 这里的哈希表、B树、阵列，它们是不同的数据结构。根据他们能够得到的时间复杂的不同，我们当然会尽可能选择时间复杂度低的那一个。 二、数据结构 数据结构可以类比为房屋结构，就像不同屋子有不同的结构一样，每种不同的房屋结构会有不同的用途。比如工业厂房会很大，而且比较空旷，用于进行工业生产；写字楼的结构比较复杂，用于人们上班办公；居民房的结构相比会小一些，用于居住等。数据结构也一样，不同的数据结构有不同的适用场景，我们不能直接评论数据结构的好坏之分，但是会有一个评判标准，就是处理数据的速度。 如上所说的一样，不同的房屋结构适用于不同场景。数据结构也一样，有的数据结构善于处理这种情况，有的数据结构善于处理那种情况。例如： 阵列，用于数据量比较小的情况，它的时间复杂度为 O(n) 树，善于处理“查找一个确定值”的情况，它的时间复杂度为O(log(n))，树是阵列的优化。 B树，善于处理“查找范围值”的情况，它需要消耗 M+log(N)次运算 哈希表，用于快速查找某个值。 数据结构是数据库内部的基本组件。 三、数据库概览数据库说白了，其实是一堆文件的集合，一个信息集合，对这一堆文件进行精心的设计就是数据库干的工作。比如可以快速处理数据（如查询），使用事务来保证数据的安全和唯一性等。 数据库是信息的集合，那么可以把它想象成数据的仓库。既然是仓库，那么就需要管理，管理就需要工具，数据库的各种组件就属于是工具，他们用来管理这个大仓库中的不同事务。这张图上列出了数据库内的各组件。包括客户端管理器、查询管理器、数据管理器等。 下一篇将会着重介绍数据库的一个很重要的管理器–查询管理器。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"http://yoursite.com/tags/时间复杂度/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"Rails项目部署","slug":"Rails项目部署","date":"2018-01-06T07:47:04.000Z","updated":"2018-02-08T14:43:15.489Z","comments":true,"path":"2018/01/06/Rails项目部署/","link":"","permalink":"http://yoursite.com/2018/01/06/Rails项目部署/","excerpt":"","text":"基本配置： （1）服务器类型：阿里云服务器 （2）镜像系统：Ubuntu 16.04 64位 （3）web服务器： Nginx + Passenger （4）数据库服务器：MySQl 基本知识： 基本CLI指令。date 会显示系统时间uname -a 显示系统版本uptime 查电脑开机多久了which 查询执行档的确切位置history 查询刚刚执行过的指令 vi 、nano、vim是三种文档编辑器，nano与vim是操作系统内建的。 传档案：SSH 通信协议除了可以让我们登入远端的服务器，也可以作为档案传输使用，又叫做 SFTP。例如： 1scp test.txt root@106.14.190.181:~/ 这个命令的意思是将本机的test.txt文件传到服务器上root账号的 ~/ 文件夹下； 1scp root@106.14.190.181:~/test.txt ./ 这个命令的意思是将服务器上的text.txt 文件传到本机 压缩与打包：如果要向服务器传很多档案，那么使用压缩打包的方式会很快；压缩和打包是可以分开的：gzip 只能压缩一个档案、tar 可以打包整个目录顺便压缩。 gzip 压缩档案 gzip -d 解压缩档案 tar zcvf xxx.tar.gz xxx将 xxx目录打包并压缩成 xxx.tar.gz 档案 tar zxcf xxx.tar.gz 将 xxx.tar.gz 解压缩 一、更新并安装Linux套件apt-get 是Ubuntu内建的套件管理工具。拿到一台服务器，首选应该做的是更新上面的套件。1- 执行 pt-get update 。 2- 执行 apt-get upgrade -f 。 3- 设定时区：dpkg-reconfigure tzdata,进入菜单后选择Shanghai。 4- 安装Ruby on Rails所需 的东西：1apt-get install -y build-essential git-core bison openssl libreadline6-dev curl zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 autoconf libc6-dev libpcre3-dev libcurl4-nss-dev libxml2-dev libxslt-dev imagemagick nodejs libffi-dev 二、安装Ruby使用Brighbox编译好的Ruby套件进行安装。1- 执行 apt-get install software-properties-common 2- 执行 apt-add-repository ppa:brightbox/ruby-ng 3- 执行 apt-get update 4- 执行 apt-get install ruby2.4 ruby2.4-dev 执行完上面四个命令后，执行 ruby -v检查ruby是否成功安装5- 安装Bundler，执行gem install bundler --no-ri --no-rdoc --source https://gems.ruby-china.org 三、安装MySQL1- 执行 sudo apt-get install mysql-common mysql-client libmysqlclient-dev mysql-server，然后根据提示设置登录密码 2- 执行mysql -u root -p 登录数据库，输入CREATE DATABSE your-database-name CHARACTER SET utf8mb4 四、安装Nginx + PassengerNginx是目前很流行的一种网站服务器，我们用它来处理静态资源，例如CSS/JS;Passenger 是一个 app server，支持基于 Rack 框架的 Ruby app（包括 Rails）。Passenger 的特点是需要作为模块编译到 Nginx 中，优点是配置简单，不需要自己写启动脚本。以下是安装步骤： 1- 通过apt安装Passenger，这里需要导入Passenger密钥1apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 561F9B9CAC40B2F7 2- 安装apt插件以支持http传输1apt-get install -y apt-transport-https ca-certificates 3- 添加apt的源1sh -c 'echo deb https://oss-binaries.phusionpassenger.com/apt/passenger xenial main &gt; /etc/apt/sources.list.d/passenger.list’ 之后执行 apt-get update 4- 安装Passenger的包1apt-get install -y nginx-extras passenger 修改Nginx配置，编辑/etc/nginx/nginx.conf改为下面这样：123456789101112131415161718192021222324252627282930313233343536 # 让 Nginx 可以读到环境变量 PATH，Rails 需要这一行才能调用到 nodejs 来编译静态档案。+ env PATH; user www-data; worker_processes auto; pid /run/nginx.pid; events &#123; worker_connections 768; # multi_accept on; &#125; http &#123; # 关闭 Passenger 和 Nginx 在 HTTP Response Header 的版本资讯，减少资讯洩漏+ passenger_show_version_in_header off;+ server_tokens off; # 设定档案上传可以到100mb，默认只有1Mb超小气的，上传一张图片就爆了+ client_max_body_size 100m; gzip on; gzip_disable \"msie6\"; # 最佳化 gzip 压缩+ gzip_comp_level 5;+ gzip_min_length 256;+ gzip_proxied any;+ gzip_vary on;+ gzip_types application/atom+xml application/javascript application/x-javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/xml text/plain text/javascript text/x-component; # 打开 passenger 模组- # include /etc/nginx/passenger.conf;+ include /etc/nginx/passenger.conf; # 下略 新增/etc/nginx/sites-enabled/example.conf1234567891011121314151617server &#123; listen 80; server_name 47.92.82.116; # 你的服务器 IP 位置 root /home/deploy/example/current/public; # example改为你自己的项目名称 passenger_enabled on; passenger_min_instances 1; location ~ ^/assets/ &#123; expires 1y; add_header Cache-Control public; add_header ETag \"\"; break; &#125;&#125; 完成Nginx的设定之后，执行 service nginx restart。 此时使用你的Ip地址打开网页如下图： 五、 安装Capistrano自动化部署1- 本机安装gem &#39;capistrano-rails&#39;与 gem &#39;capistrano-passenger &#39; 2- capistrano 文件设定 执行 cap install ，新增capistrano 的配置档案，编辑以下文件： （1）Capfile 1234require \"capistrano/scm/git”install_plugin Capistrano::SCM::Git+ require 'capistrano/rails’+ require 'capistrano/passenger’ （2）config/deploy.rb1234567891011121314151617181920212223242526272829303132333435363738394041424344+ sh \"ssh-add\" # config valid only for current version of Capistrano lock \"3.8.1\"- set :application, \"my_app_name\"+ set :application, \"rails_recipes\" # 请用你自己的项目名称- set :repo_url, \"git@example.com:me/my_repo.git\"+ set :repo_url, \"git@github.com:growthschool/rails-recipes.git\" # 请用你自己项目的git位置 # Default branch is :master # ask :branch, `git rev-parse --abbrev-ref HEAD`.chomp # Default deploy_to directory is /var/www/my_app_name # set :deploy_to, \"/var/www/my_app_name\"+ set :deploy_to, \"/home/deploy/rails-recipes\" # 这样服务器上代码的目录位置，放在 deploy 帐号下。请用你自己的项目名称。 # Default value for :format is :airbrussh. # set :format, :airbrussh # You can configure the Airbrussh format using :format_options. # These are the defaults. # set :format_options, command_output: true, log_file: \"log/capistrano.log\", color: :auto, truncate: :auto # Default value for :pty is false # set :pty, true # Default value for :linked_files is []- # append :linked_files, \"config/database.yml\", \"config/secrets.yml\"+ append :linked_files, \"config/database.yml\", \"config/secrets.yml\" # Default value for linked_dirs is []- # append :linked_dirs, \"log\", \"tmp/pids\", \"tmp/cache\", \"tmp/sockets\", \"public/system\"+ append :linked_dirs, \"log\", \"tmp/pids\", \"tmp/cache\", \"tmp/sockets\", \"public/system\"+ set :passenger_restart_with_touch, true # Default value for default_env is &#123;&#125; # set :default_env, &#123; path: \"/opt/ruby/bin:$PATH\" &#125; # Default value for keep_releases is 5- # set :keep_releases, 5+ set :keep_releases, 5 (3) config/deploy/production.rb123+ set :branch, \"master\"- # server \"example.com\", user: \"deploy\", roles: %w&#123;app db web&#125;, my_property: :my_value+ server \"47.92.82.116\", user: \"deploy\", roles: %w&#123;app db web&#125;, my_property: :my_value, 其中user为你自己设定的用户名称 之后的步骤是根据cap production deploy:check检查缺少哪些文件，按照提示新增缺少的文件即可，一般需新增database.yml与secrets.yml这两个个文件。 最后在本机执行 cap production deploy ,完成部署。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"Rails部署","slug":"Rails部署","permalink":"http://yoursite.com/tags/Rails部署/"},{"name":"Ubuntu + Nginx + Passenger","slug":"Ubuntu-Nginx-Passenger","permalink":"http://yoursite.com/tags/Ubuntu-Nginx-Passenger/"}]},{"title":"SQL基础","slug":"SQL基础","date":"2018-01-04T07:09:29.000Z","updated":"2018-02-08T14:45:13.977Z","comments":true,"path":"2018/01/04/SQL基础/","link":"","permalink":"http://yoursite.com/2018/01/04/SQL基础/","excerpt":"","text":"SQL，Structure Query Language，结构化查询语言，是关系型数据库的应用语言。 一、分类 DDL（Data Defintion Language ）语句：数据定义语言，定义了不同的数据段、数据库、表、列、索引等数据库对象，常用的语句的关键字包括 create、drop、alter等。 DML（Data Manipulation Language）语句：数据操纵语句，用于增删改查数据库记录，并检查数据的完整性。关键词： insert、delete、update、select。 DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的许可。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。关键词：grant、revoke。 二、DDL语句 DDL语句一般情况下是由数据库管理员（DBA）使用，与DML的最大区别是DML只对表内数据进行操作，而不设计表的定义、结构和修改。以下命令均为在指定数据库内操作，因此不用指明是在哪里数据库里新增等，若没有指定，则需要加上数据库的名称。 创建数据库 - CREATE DATABASE dbname; （CREATE DATABASE 也可小写 ） 删除数据库 - DROP DATABASE dbname； 创建表 - 1234CREATE TABLE tablename（ column_name_1 column_type_1_constraints, column_name_2 column_type_2_constraints, ... column_name_n column_type_n_constraints） 查看表结构 —— DESC tablename 更全面地查看表定义 —— show create table tablename \\G; 这条命令可以看到创建表的SQL语句,其中“\\G”的意思是使得记录能够按照字段竖向排列，也就是改变我们看到的格式。 删除表 - DROP TABLE tablename 修改表- 修改表类型（字段的类型）1ALTER TABLE tablename MODIFY[COLUMN] column_definition [FIRST|AFTER col_name] 例如，在mysql环境下执行，alter table emp modify ename varchar(20)。 增加表字段 1ALTER TABLE table_name ADD[COLUMN] column_definition [FIRST|AFTER col_name] 例如， alter table emp add column age int(3); 删除表字段 -ALTER TABLE table_name DROP [COLUMN] col_name;例如， alter table emp drop column age； 字段改名 -1ALTER TABLE table_name CHANGE[COLUMN] old_col_name column_definition[FIRST|AFTER column_name] 例如，alter table emp change age age1 int(4);PS: chang与modify都可以修改列，但是change即可以修改列的名称，也可以修改列的类型，而modify只能修改列的类型。 修改字段的顺序 -例如，alter table emp add age int(2) after name; alter table emp change age age1 int(4) first; 修改表名 -ALTER TABLE table_name RENAME [TO] new_tablename,例如， alter table emp rename emp1; 三、DML 语句DML语句是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。 1- 插入记录插入单条记录：INSERT INTO table_name(field1, field2, … fieldn) VALUES(value1, value2, …valuen);例如，insert into emp(ename, hire,sal,deptno) values(‘zzx1’, ‘2000-1-1’, ‘2000’,1); 也可以不用指定字段名称，但是需要values后面的循序与字段的顺序一致。 插入多条记录：INSERT INTO tablename (field1, field2, … fieldn)VALUES(record1_value1, record2_value2, … record1_valuen),(record2_value1, record2_value2, … record2_valuen),…(recordn_value1, recordn_value2, … recordn_valuen);例如insert into dept VALUES(5, “35”),(3,”232”); 2- 更新记录更新记录：UPDATE tablename SET filed1= value1,field2= value2, … filedn=valuen [WHERE CONDITION],例如，`update emp set sal=4000 where ename=‘lisa’;`` 更新多个表中的记录：UPDATE t1,t2,…tn set t1.field=value1,tn.field=valuen [WHERE CONDITION] 3- 删除记录DELETE FROM tablename [WHERE CONDITION]例如，delete from emp where ename=‘lisa’; 删除多个表中的记录：DELETE t1,t2,..tn FROM t1,t2,…tn [WHERE CONDITION]PS: 不论是单表还是多表，不加where条件都会把表的所有记录删除； 4- 查询记录SELECT FROM tablename [WHERE CONDITION]例如,select from emp;,为查询emp这个表中的所有字段。如果想要部分字段的话，需要分别写出各个字段的名字，例如 select ename from emp; （1）查询重复记录用到“distinct”,例如 select distinct slaer from emp; （2）条件查询关键词：where，例如 select * from emp where name=Lisa;其中“=”也可以是&gt; &lt; &gt;= &lt;= != 多条件还可以使用or和and等逻辑运算符进行多条件联合查询。 （3）排列顺序和限制语法如下：SELECT * FROM tablename [WHERE CONDTION] [ORDER BY field1 [DESC/ASC],field2 [DESC/ASC],… fieldn [DESC/ASC]]。 不写关键字默认我ASC(升序排序)。ORDER BY 后面可以跟不同的字段，每个字段可以有不同的排序。 对于排序后的记录，如果只希望显示一部分，这时就需要用到LIMIT关键字。语法如下：SELECT … [LIMIT offset_start,row_count]。 例如select * from emp order by sal limit 3; select * from emp order by sal limit 1,3; limit 经常和 order by 一起配合使用来进行记录的分页显示。 （4）聚合 用于汇总操作，例如统计。语法如下：123456SELECT [field1,field2,…fieldn] fun_nameFROM tablename[WHERE where_condition][GROUP BY field1,field2,…fieldn [WITH ROLLUP]][HAVING where_condtion] 其中： fun_name 表示要做的聚合操作，也就是聚合函数，常用的有sum count max min GROUP BY 表示要进行分类聚合的字段，比如按照部分分类统计员工数量，部门就应该写在group by 后面 WITH ROLLUP是可选语法，表明是否对分类聚合后的结果进行再汇总 HAVING 表示对分类后的结果再进行条件的过滤。PS：having和where都是过滤，where是在聚合前过滤，having是对聚合后的结果过滤。 统计总人数： select count(1) from emp;统计各个部门的人数： select deptno,count(1) from emp group by deptno;既统计部门人数又统计总人数：select deptno.count(1) from emp group by deptno with rollup;统计部门人数大于1的部门： select deptno.count(1) from emp group by deptno having count(1)&gt;1;统计公司所有员工的公司薪水总额、最高和最低薪水：select sum(sal),max(sal),min(sal) from emp; （5）表连接表连接分为内连接和外链接，内连接仅仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录，最常用的是内连接。例如，查询所有雇员的名字和所在的部门名称，因为雇员名称和部门分别放在表emp、dept中，因此需要使用表连接来查询。select ename,deptno from emp,dept where emp.deptno=dept.deptno; （6）子查询某些情况下，当进行查询的时候，需要的条件是另外一个select语句的结果，这时就会用到子查询。关键字：in、not in、=、exists、not exists等,例如， select * from emp where deptno in(select deptno from dept)。PS：表连接在很多情况下用于优化子连接。 四、DCL语句DCL语句主要是DBA用来管理系统中的对象权限时使用，开发人员很少使用，例如1mysql &gt; grant all PRIVILEGES on db_name.* to 'username'@'xxx.xxx.xx.x' identified by 'password' WITH GRANT OPTION; grant 为放出权限，select为收回权限。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"SQL语句","slug":"SQL语句","permalink":"http://yoursite.com/tags/SQL语句/"}]},{"title":"数据库的事务与锁","slug":"数据库的事务与锁","date":"2018-01-03T07:15:58.000Z","updated":"2018-01-03T07:39:57.375Z","comments":true,"path":"2018/01/03/数据库的事务与锁/","link":"","permalink":"http://yoursite.com/2018/01/03/数据库的事务与锁/","excerpt":"","text":"学习数据库的事务与锁之前需要先了解下什么是并发： 多个用户对同一数据进行交互叫做并发。如果不加以控制，并发可能引起很多问题。数据库提供了可以合理解决并发问题的方案。 一、事务 事务的概念：类比于银行转账，A转给B100元，那么A的账户减少500，B的账户增加500元，这个两个操作必须全部执行，要么就全部不执行。数据库的的事务总是将指定的一条语句或多条语句看成一个全部执行或者全部不执行的最小组合全部组合。 事务类型：如SELECT INSERT UPDATE DELETE 1- 显示事务处理模式通过START TRANSACTION 标记事务起始点，如果开启事务后执行的语句是按照期望正确执行的则以COMMIT TRANSACTION 来结束事务；如果开始事务后执行的语句结果不是所期望的，并希望取消刚才的操作，则以ROLLBACK TRANSATION 来结束事务，（相当于撤销），该动作成为回滚。前滚指的是再次执行一次事务中的操作。 2- 自动提交事务模式默认情况下，MySQL是自动提交的。在该模式下，每条语句都被认为是一个事务。当每个SQL语句执行完成后，不是被提交就是被回滚，如果执行成功则提交，执行失败则回滚。注意：在该模式下，执行的语句如果出现编译错误（例如关键字错误）而非运行错误该批语句都不会执行，而不是执行后再回滚；如果是运行错误不会导致该批语句都不执行，而是错误语句会回滚，之前语句正常执行。 3-隐式事务处理模式可以通过 SET IMPLICIT_TRANSACTIONS ON 和 SET IMPLICIT_TRANSACTIONS OFF 来启动和关闭隐式模式。与显示事务处理模式相比，它省略了事务起始点，也就是START TRANSATION。 PS:事务也是可以嵌套的，这里不进行详细说明。 二、并发访问引起的问题并发：两个用户或者两个以上的用户在同一时间与同一对象进行交互。例如春节抢票，抢的人越多，并发数就越高，对系统性能要求就越高。 1- 丢失更新当两个或多个事务对同一数据最初的值进行更新时，由于每个事务都不知道其他事务的存在，最后提交的事务中的更新操作就会覆盖掉其他事务所做的更新，这就导致其他事务的更新操作丢失。 2- 脏读事务完成数据更新后，这时其他事务去查询该行数据的时候读取的数据是临时的，如果最后更新的事务被回滚，这个临时数据对于查询的事务来说就是“脏数据”。 3- 不可重复读在一个事务两次的查询之间，同一数据被其他事务更新，导致同一事务中的两次查询结果不同，这样的现象叫做不可重复读。确定的某条记录。 4- 幻影读一个事务中指定范围的两次查询结果因为其他事务更新了符合范围的数据，导致两次结果查询结果不同，这样的现象叫做幻影读。幻影读不仅仅只适用于符合条件的范围内的记录有多少，还适用于涉及到范围概念的情况。与范围数据有关。 三、锁锁，即锁定，在数据库的概念为：在哪些数据或者对象上获取了锁就对对应的数据或者对象进行了锁定，其他事务就无法获取和现有锁相冲突的锁。锁是事务用来保护与自己交互的数据或者对象不受其他事务干扰的机制，实现了事务与事务之间的隔离。正是因为锁的存在，才可以根据业务需求合理地解决并发访问带来的问题。 1- 锁的粒度与锁升级数据库可以在某一行获取锁，也可以对某一张表获取锁，也可以对整个数据库获取锁。这种多层次的锁结构成为锁的粒度。锁的粒度越粗，并发度越低，系统性能越高。下面可以申请锁的粒度类型： 行或行标识符（RID）：属于行级锁（InnoDB），用于锁定堆中某个行的行标识符。 键（Key）：属于行级锁，在索引的键上存放锁，用户保护事务中的键的范围。 页（Page）：锁定该页中的所有数据或键。 区（Excent）：锁定整个区段，包括里面的页以及页中的数据行和键。 表（Table）：锁定整个表以及与表关联的所有对象，如表中的数据行、索引键。 数据库（Database）：锁定整个数据库。 由低层次的锁升级到高层次的锁成为锁升级。 2- 锁的类型数据库引擎基于事务类型选择不同的锁，这些锁决定了并发事件访问资源的方式。此处只列出三种类型的锁。 （1）共享锁（S锁）共享锁用于只需要读取不需要进行修改或更新数据的操作，如SELECT语句就是一种最基本常见的申请共享锁的语句。共享锁避免了不可重复读与幻影读问题。 （2）独占锁（X锁）独占锁也成为排他锁。与其他所有的锁都冲突。当需要进行数据更改操作如INSERT、UPDATE、DELETE时，锁管理器就会分配X锁。一般情况下，数据修改时包含两个动作：读取需要的数据和修改数据，因此在数据修改时会申请共享锁和独占锁。在同一张表中修改数据，此时共享锁更应该成为更新锁，但是如果更新操作连接了其他表，那么其他表中就会存在共享锁，并在需要的数据上申请独占锁。 （3）更新锁（U锁）更新锁和共享锁兼容，和独占锁冲突。更新锁和更新锁也冲突。修改数据时会先申请更新锁后申请独占锁， 更新锁是一种过渡锁。在进行数据搜索时持有了更新锁，由于更新锁和共享锁兼容，因此此时其他事务是允许读取数据的，当确定修改数据后，更新锁等待其他事务的共享锁释放后就会转换为独占锁（那么等待时间如何计算？），并将其他事务的相关资源的锁申请全部队列化堵在数据修改的进程外，直到独占锁释放，其他事务才能进行相关资源的申请。 死锁：两个事务都在等待一个资源，但同时又相互阻止对方获取资源，这时就会发生死锁现象。例如，事务A和事务B都获取了某一行数据的共享锁（也就是可以查看该数据），当事务A想修改该数据时要将共享锁转化为独占锁，这就需要等待事务B释放共享锁，但是事务B也想修改数据，将共享锁转换为独占锁，它将等待事务A释放共享锁，这样两个事务之间形成了僵局。 更新锁和共享锁是兼容的，因此更新锁和共享锁可能在同一资源上相互共存，但是更新锁和更新锁是相互冲突的，所以只能有一个事务对数据有更新锁。在过度为独占锁前，只有更新锁的事务必须先等待其他事务释放所有的共享锁，这就避免了上述的死锁问题。 四、事务隔离级别在数据库系统中可以通过设置事务隔离级别间接地控制锁，实现事务之间的隔离，从而解决并发问题。事务隔离级别是并发控制的整体解决方案，其实质是通过控制锁来控制事务之间如何进行隔离。 1- 提交读（READ COMMITTED）查询申请的共享锁在语句执行完毕后就释放，不需要等待事务结束后释放；数据修改申请的独占锁一直持有，直到事务结束才释放。设置提交读，可以避免脏读问题，但是不能解决不可重复读和幻影读。 PS：设置事务隔离级别和查看。隔离级别的设置是对会话级别的，所以只对当前会话有效。 2- 可提交读（READ UNCOMMITTED）未提交读是控制级别最低的级别，设置之后，该会话的所有读操作将不申请共享锁，因此读时将忽略所有的锁，但是更新时仍然会申请独占锁，这种情况下并发带来的问题都有可能发生。 3- 可重复读（REPEATABLE READ）MySQL默认事务隔离级别，当设置为可重复读隔离级别时，除了独占锁会一直保持到事务结束，共享锁也一样到事务结束。可重复读隔离级别下，脏读、丢失的更新和不可重复读问题都能够避免，但是也因为共享锁一直持有，会导致其他事务不能对相关数据进行修改，降低了并发度和性能。可重复读隔离级别无法解决幻影读问题。 4- 串行化（SERIALIZABLE）串行化隔离级别隔离层次最高，它能够避免丢失的更新、脏读、不可重复读和幻影读问题。设置为串行化隔离级别后，共享锁也将一直持有到事务结束。比可重复读更严格的是它的锁定是范围的，还包括潜在的数据修改。它保证了范围内两次查询结果不会出现增加记录或减少记录而出现幻象。 串行化隔离级别对锁控制的方式为：如果在查询指定条件的列上有索引，则在该列符合条件的范围记录上加上KEY粒度的锁，如果在查询条件的列上没有索引，则直接在表上加上共享锁。 五、隔离级别、锁和并发问题的关系","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"数据库事务","slug":"数据库事务","permalink":"http://yoursite.com/tags/数据库事务/"},{"name":"数据库的锁","slug":"数据库的锁","permalink":"http://yoursite.com/tags/数据库的锁/"}]},{"title":"网络基础-HTTP","slug":"网络基础-HTTP","date":"2018-01-02T14:25:13.000Z","updated":"2018-01-02T15:10:39.828Z","comments":true,"path":"2018/01/02/网络基础-HTTP/","link":"","permalink":"http://yoursite.com/2018/01/02/网络基础-HTTP/","excerpt":"","text":"最近Rails项目部署的过程中遇到网络端口的问题及用到了http网络协议的知识，于是决定对这块知识进行回顾和重新梳理，这里推荐韩立刚老师的《计算机网络原理》一书，讲的很明白。以下为这次学习到的主要内容： HTTP( Hyper Text Transfer Protocol) WWW( World Wide Web),互联网上的网站共同组成万维网。 URL( Uniform Resource Locator)，统一资源定位符，网站的网址。URL一般由四个部分组成：&lt;协议&gt;://&lt;主机&gt;:&lt;/端口&gt;/&lt;路径&gt;，例如http://106.14.190.181:80/wx 一、HTTP协议版本：1- HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，既不跟踪每个客户也不记录过去的请求。 2- HTTP1.1支持持续连接，即服务器在发送响应后，仍然在一段时间内保持这条TCP连接，使得同一个浏览器和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。HTTP1.1的持续连接有两种工作方式，即非流水线方式和流水线方式。非流水线方式（理解为迅雷一次只能下载一个文件）的特点是客户在收到前一个响应后才能发送写一个请求。因此，在TCP连接建立后，客户每访问一次对象都要用去一个往返时间RTT，这种方式浪费服务器资源。流水线的特点（理解为迅雷一次可以下载多个文件）是客户在收到HTTP响应报文之前就能够发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文，这种方式使TCP连接中的空闲时间减少，提高了文档的下载效率。 3- HTTP请求报文与响应报文（1） 请求报文：从客户端向服务器发送请求报文 请求报文由三个部分组成：分别是请求行，首部行，实体主体。请求报文的第一行“请求行”只有三个内容，即方法、请求资源的URL，以及HTTP的版本。方法就是对对象的操作，HTTP1.1协议中定义了八中方法，来表明对Request-URL指定资源的不同操作方式：GET、POST、PUT、DELETE、HEAD、TRACE、CONNECT、OPPIONS（2）响应报文：从服务器到达客户端的应答 二、CookieHTTP是一种无状态的协议，当你注册登录一个网站后，当下次再打开这个网站后，需要再次输入账号与密码进行身份验证，服务器仅从网络连接上无从知道你的曾经登录的身份。如果希望服务器读取你的曾经登录的身份，那就需要在用户输入账号和密码后，服务器在用户的计算机存放一个通行证，来记录用户的身份和状态。以后再访问，网站（服务器）就会先读取客户端的通行证。服务器存放在客户端（浏览器）的通行证通常被称为cookie。 cookie实际上是一小段的文本信息（说明可以进行拷贝，也就是在其他浏览器导入cookie之后不用输入账号和密码就可以登录了）。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端把浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器吧请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份和状态。服务器还可以根据需要修改cookie的内容。 三、通过代理服务器访问网站代理服务器英文全称为Proxy Server，其功能就是代理网络用户去取得网络信息。我们可以配置计算机通过Web代理服务器访问Web站点，而不直接访问网站。 使用代理服务器的场景：（1）使用代理服务器，绕过防火墙封锁。国内不允许网民访问国外的非法网站，在我国的防火墙上设置了拦截到这些网站的流量。但是国外有很多的web代理服务器，国内用户可以设置浏览器使用国外的代理商服务器，然后访问非法网站，就能成功。现在有很多“翻墙”软件，其实质就是使用国外代理服务器绕过国内封锁，故称为“翻墙”。（2）提高访问速度通常代理服务器可以缓存用户访问过的内容，当其他用户再访问相同的URL时，由代理服务器直接从缓存中找到要访问的信息，传给用户，已提高访问速度。例如，在企业内网部署一个Web代理服务器，能节省上网带宽。（3）隐藏真实IP上网者也可以通过这种方法隐藏自己的IP。有些网站的论坛会记录发帖人的IP地址。如果你不打算让论坛记录你真是的IP地址，就可以使用代理服务器访问该网站，发帖，这样只会记录下代理的地址，从而隐藏自己的IP地址。 国内外有很多免费的代理服务器，例如西刺免费代理。上面可以看到免费的代理服务器，在浏览器中设置使用这些代理服务器访问Internet。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/tags/网络基础/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"超文本协议","slug":"超文本协议","permalink":"http://yoursite.com/tags/超文本协议/"}]},{"title":"注册与登录","slug":"注册与登录","date":"2017-12-21T13:15:56.000Z","updated":"2017-12-30T12:24:12.991Z","comments":true,"path":"2017/12/21/注册与登录/","link":"","permalink":"http://yoursite.com/2017/12/21/注册与登录/","excerpt":"","text":"rails 中的gem devise提供了注册与登录的功能，用起来比较方便。但是为了自身编程能力，决定学习如何自写出注册与登录功能。 注册功能用户注册即创建一个用户，这时会用到我们所熟知的CRUD。理解起来很容易，但是做起来并没有那么简单。 首先需要生成user的model，并对其字段进行约束，通常情况下，会是name与email，例如name与email都不为空、长度、格式，为邮箱加索引等，把这些设置好之后，需要设置路由，控制器，还有视图。 Model约束字段。例如name与email的长度、格式、不为空，密码长度等，且为邮箱加索引。 routes.rb设置注册路由，一般会是get &#39;/signup&#39;, to: &#39;users#new&#39; post &#39;/signup&#39;, to: &#39;users#create&#39; Views设置注册表单。其中会用到form_for或者 simple_form_for Controllers编写users#new与 users#create 验证用户验证用户会用密码，因为我们会为user增加一个字段名称password_digest，在user的model中，添加has_secure_password这个方法（因为has_secure_password这个方法调用唯一要求就是对应的model中有password_digest 字段），它有三个作用: (1) 在数据库层中的password_digest中存储安全的密码哈希值（2）获得一对虚拟属性，password password_confirmation,而且创建对象时会执行存在性验证和匹配验证（3）获得authenticate方法，如果密码正确，返回用户对象，如果密码错误，返回false。 要想生成不可逆的密码哈希值，我们需要用到gem &#39;bcrypt&#39;,它的作用就是生成哈希密码值。这样即使‘脱库’，用户的真实密码也不会丢失。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"用户系统","slug":"用户系统","permalink":"http://yoursite.com/tags/用户系统/"}]},{"title":"部分gem总结","slug":"部分gem总结","date":"2017-09-06T17:54:55.000Z","updated":"2018-02-02T04:45:27.453Z","comments":true,"path":"2017/09/07/部分gem总结/","link":"","permalink":"http://yoursite.com/2017/09/07/部分gem总结/","excerpt":"","text":"1.gem ‘devise’ ———————————— 登录系统 安装须知： 依次执行bundle install rails g devise:install rails g devise user rake db:migrate，最后重新rails s。 2.gem ‘bootstrap-sass’ ———————————— 前端开发套件 安装须知：(1) 依次执行bundle install mv app/assets/stylesheets/application.css app/assets/stylesheets/application.scss;(2) app/assets/stylesheets/application.scss123+@import \"bootstrap-sprockets\";+@import \"bootstrap\"; 最后重新rails s 3.gem ‘simple_form’ ———————————— 简化表单 安装须知： 依次执行bundle install rails g simple_form:install --bootstrap,最后重新rails s 4.gem ‘font-awesome-rails’ ———————————— 图标套件 安装须知 （1）bundle install ,重新rails s（2） app/assets/stylesheets/application.scss1@import \"font-awesome\"; 5.gem ‘better_errors’ ———————————— 更好的显示错误讯息 安装须知 bundle install 重启rails s 6.gem ‘annotate’ ———————————— 在主要用于model中显示栏位 安装须知 bundle install 重启rails s执行annotate --exclude tests,fixtures,factories,serializers,ps：每次新增栏位后，都要执行这个命令，才会在具体model里显示出所有建立的栏位提示。 7.gem ‘awesome_rails_console’ —————————- 让“金手指”变好看的套件 安装须知 bundle install 重启rails s 8.gem ‘carrier_wave’ gem ‘mini_magick’ ———————————— 用于上传图片（可能还有其他的功能） 安装须知 依次执行：bundle install rails g uploader image 重启rails s","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"Gem","slug":"Gem","permalink":"http://yoursite.com/tags/Gem/"}]},{"title":"两种方法实现收藏或者点赞功能","slug":"两种方法实现收藏或者点赞功能","date":"2017-09-06T16:30:24.000Z","updated":"2018-01-02T14:24:18.694Z","comments":true,"path":"2017/09/07/两种方法实现收藏或者点赞功能/","link":"","permalink":"http://yoursite.com/2017/09/07/两种方法实现收藏或者点赞功能/","excerpt":"","text":"收藏功能与点赞功能的实作十分类似，本文以购物车教程实作收藏功能为例。 方法一：step1一个用户可以收藏多个商品，一个商品可以被收藏很多次，因此这是多对多的关系。因此需要新增一个model，来当做product与suer的桥梁。$ rails g model collect user_id:integer product_id:integer,然后执行 rake db:migrate，然后为collect、user与product这三个model加上关联。 app/models/collect.rb123456789 + belongs_to :user + belongs_to :product``` ``` ruby app/models/product.rb + has_many :collects + has_many :collected_users, through: :collects, source: :user app/models/user.rb1234567891011121314151617181920 + has_many :collects + has_many :collected_products, through: :collects, source: :product #加上是否收藏商品的判定 + def is_collect_of?(product) + collected_products.include?(product) + end``` #### step2首先修改路由信息：``` ruby config/routes.rb + resources :product do + member do + post :collect + post :uncollect + end + end 在controller里加上对应的method， app/controllers/product_controllers.rb1234567891011121314+ def collect + @product = Product.find(params[:id]) + current_user.collected_products &lt;&lt; @product + flash[:notice] = \"成功收藏商品\" + redirect_to :back+ end+ def uncollect + @product = Product.find(params[:id]) + currrent_user.collected_products.delete(@product) + flash[:warning] = \"您已取消收藏该商品\" + redirect_to :back+ end step3在views中的相应位置加入收藏的显示 app/views/products/show.html.erb123456+ &lt;% if current_user &amp;&amp; current_user.is_collect_of?(@product) %&gt;+ &lt;%= link_to(“取消收藏”, uncollect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\" )%&gt;+ &lt;% else %&gt;+ &lt;%= link_to(\"收藏“, collect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\" )%&gt;+ &lt;% end %&gt; 方法二step1同样，终端执行 rails g model colloect, 编辑 db/migrate/XXXXXXXX_create_collects.rbdb/migrate/XXXXXXXX_create_collects.rb 123456789 class CreateCollects &lt; ActiveRecord::Migration[5.0] def change create_table :collects do |t|+ t.integer :user_id, :index =&gt; true+ t.integer :product_id, :index =&gt; true t.timestamps end end end 之后执行 rake db:migrate 编辑app/models/collect.rb,加上关联app/models/collect.rb12+ belongs_to :user+ belongs_to :product 编辑 app/models/product.rb,加上关联app/models/product.rb123456789101112 + has_many :collects, :dependent =&gt; :destroy + had_many :collected_users, through: :collects, source: :user + def find_collect(user) + self.collects.where( :user_id =&gt; user.id).first + end``` 编辑 `app/model/user.rb`,加上关联``` ruby app/models/user.rb + has_many :collects, :dependent =&gt; :destroy + has_many :collected_products, through: :collects, source: :product step2编辑路由信息config/routes.rb123456+ resource :products do+ member do+ post :collect+ post :uncollect+ end+ end 在controller中添加：app/controllers/product_controller.rb12345678910111213141516+ def collect + @product = Product.find(params[:id]) + unless @product.find_collect(cuurent_user) + Collect.create( :user =&gt; current_user, :product =&gt; @product) + flash[:notice] = \"您已成功收藏该商品\" + end + redirect_to :back+ end+ def uncollect + @product = Product.find(params[:id]) + collect = @product.find_collect(current_user) + collect.destroy + flash[:warning] = \"您已取消收藏该商品\" + redirect_to :back+ end Step3最后一歩，就是要在 app/views/products/show.html.erb中加上收藏的按钮 app/views/products/show.html.erb123456789……略 + &lt;% if current_user %&gt; + &lt;% if @product.find_collect(current_user)%&gt; + &lt;% =link_to(\"取消收藏\", uncollect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\")%&gt; + &lt;% else %&gt; + &lt;%= link_to(\"收藏\", collect_product_path(@product), :method =&gt; :post, class: \"btn btn-primary btn-lg\")%&gt; + &lt;% end %&gt; + &lt;% end %&gt;……略 成果展示","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"}]},{"title":"利用ransack做搜索功能","slug":"利用ransack做搜索功能","date":"2017-09-06T16:27:42.000Z","updated":"2018-02-08T14:40:14.026Z","comments":true,"path":"2017/09/07/利用ransack做搜索功能/","link":"","permalink":"http://yoursite.com/2017/09/07/利用ransack做搜索功能/","excerpt":"","text":"本篇教程基于自己的一个小项目，用户可以搜索网站上其他用户发表过的文章。 第一歩：安装gem ransack ransack会用数据库的LIKE语法来做搜寻，虽然比较方便，但它会依次检查资料是否符合，而不会使用数据库的索引。如果数据比较庞大的话，利用ransack将不会是一个好的选择。这时候我们就可以安装专门的全文搜索引擎，例如Elasticsearch Gemfile1+ gem 'ransack' $ bundle，重启 rails s 第二歩controller与config的设定 1、设置路由config/routes.rb1234567891011121314151617181920212223242526272829303132333435 Rails.application.routes.draw do devise_for :users resources :posts do + collection do #我们会搜索出所有符合关键字的文章，结果为复数，因此用collection，而不是member + get :search + end end end ``` #### 2、设置controller主要设置通过哪些关键词进行搜索。```ruby app/controllers/posts_controller.rb class PostsController &lt; ApplicationController before_action :validate_search_key, only: [:search] def search if @query_string.present? @posts = search_params #搜索post的关键词 end end protected # 放在最后 def validate_search_key # gsub 是Ruby中正则表达式的方法，它会切换所有匹配到的部分 @query_string = params[:q].gsub(/\\\\|\\'|\\/|\\?/, \"\")if params[:q].present? end def search_params Post.ransack(&#123;:title_or_content_cont =&gt; @query_string&#125;).result(distinct: true) #title与content是post的两个栏位，而我们的关键词出自这里 end end 第三歩views的设定 1、导航栏的显示app/views/common/_navbar.html.erb12345678910 &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; + &lt;ul class=\"nav navbar-nav\"&gt; + &lt;li&gt; + &lt;div class=\"form-group form-inline search-bar\"&gt; + &lt;%= render :partial =&gt; \"posts/search_bar\"%&gt; + &lt;/div&gt; + &lt;/li&gt; + &lt;/ul&gt; …… 略&lt;/div&gt; 执行$ touch app/views/posts/_search_bar.html.erb,并编辑app/views/posts/_search_bar.html.erb1234567891011121314 &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-9 col-lg-8 col-lg-offset-2\"&gt; &lt;%= form_tag search_posts_path, :class =&gt; \"posts-search-form\", :method =&gt; :get do %&gt; &lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control search-bar-input\" name=\"q\" value=\"&lt;%= params[:q] %&gt;\" placeholder=\"关键词\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button type=\"submit\" class=\"btn btn-default search-bar-submit\"&gt; &lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/div&gt; 2.搜索反馈页面新增 app/views/posts/search.html.erbapp/views/posts/search.html.erb123456789101112131415161718192021222324252627282930313233&lt;div class=\"minHeight1000 bg-gray\"&gt; &lt;div class=\"search-page w1200 pt30 bc\"&gt; &lt;% if @posts.present? %&gt; &lt;h5 class=\"collection search-count\"&gt;已为您找到&lt;%= @posts.count %&gt;篇相关文章&lt;/h5&gt; &lt;% else %&gt; &lt;p class=\"tc mt100\"&gt;未搜索到任何文章，要不换个关键词试试？&lt;/p&gt; &lt;% end %&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;% @posts.each do |post| %&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;%= post.title %&gt; &lt;br/&gt; &lt;br/&gt; &lt;span id=\"psot-thumbsup-&lt;%= post.id%&gt;\" class=\" label label-success\"&gt;&lt;%= post.likes.count%&gt;👍&lt;/span&gt; &lt;div class=\"text-right\"&gt; &lt;% if !current_user.is_collect_of?(post) %&gt; &lt;%= link_to(\"收藏\", collect_post_path(post), method: :post, class: \"btn btn-sm\") %&gt; &lt;% else %&gt; &lt;%= link_to(\"取消收藏\", uncollect_post_path(post), method: :post, class: \"btn btn-sm\") %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/div&gt; 效果图","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"ransack","slug":"ransack","permalink":"http://yoursite.com/tags/ransack/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-06T09:33:31.000Z","updated":"2017-09-06T09:33:31.000Z","comments":true,"path":"2017/09/06/hello-world/","link":"","permalink":"http://yoursite.com/2017/09/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}