{"meta":{"title":"jonathan-fei.pro","subtitle":null,"description":"Stay hungry. Stay foolish.","author":"jonathan-fei","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-12-30T12:21:04.000Z","updated":"2017-12-30T12:21:51.399Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-30T12:23:01.000Z","updated":"2017-12-30T12:23:14.179Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"N + 1 问题的解决方案","slug":"N-1-问题的解决方案","date":"2018-02-07T02:38:06.000Z","updated":"2018-02-07T03:06:15.973Z","comments":true,"path":"2018/02/07/N-1-问题的解决方案/","link":"","permalink":"http://yoursite.com/2018/02/07/N-1-问题的解决方案/","excerpt":"","text":"Rails中的Active Record的关联功能很强大，但是有时会产生N+1 SQL 查询问题。比如查看一篇文章下的很多评论就会产生N+1 问题。PS: 问题往往出现在一对多和多对多的关系中。参考资料： ihower实战圣经 解决思路如下： 1. 安装检测工具（1）gem &#39;rack-mini-profiler&#39; ，效能检测工具。安装后，网页上左上角会出现网页加载时间的提示。（2）gem &#39;bullet&#39;, group: &#39;development&#39;, N+1 query检测工具。使用流程可参考：bulldet，当你的代码存在N+1问题时，会出现例如下面的提示：1234USE eager loading detected Post =&gt; [:user] Add to your finder: :includes =&gt; [:user]Call stack 2. 使用 inclueds 关联（1）model 之间的关系1234567class User &lt; ApplicationRecord has_many :postsendclass Post &lt; ApplicationRecord belongs_to :userend （2）修改控制器中代码12345class PostsController &lt; ApplicationController def index posts = Post.includes(:user).page(params[:page]) endend 此时，就会观察到rails log中只会出现两条SQL查询语句,。12Comment Load (0.5ms) SELECT &quot;comments&quot;.* FROM &quot;comments&quot; WHERE &quot;comments&quot;.&quot;post_id&quot; = ? [[&quot;post_id&quot;, 1]] User Load (0.4ms) SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;id&quot; IN (4, 18, 2, 14, 13, 3, 12) N + 1 其实属于是慢查询的问题，下面就大体总结下解决慢查询问题及解决方法： N + 1 ——– ——–includes 大量数据 ———– find_each（或者 find_in_batches） 查询慢 ————– 加 索引 捞出所需字段 —— select 方法 计数快取 ———- Counter cache","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"N+1 SQL查询","slug":"N-1-SQL查询","permalink":"http://yoursite.com/tags/N-1-SQL查询/"},{"name":"rails","slug":"rails","permalink":"http://yoursite.com/tags/rails/"},{"name":"慢查询","slug":"慢查询","permalink":"http://yoursite.com/tags/慢查询/"}]},{"title":"使用 carrierwave 实现图片上传","slug":"使用-carrierwave-实现图片上传","date":"2018-02-06T15:36:16.000Z","updated":"2018-02-07T04:26:02.196Z","comments":true,"path":"2018/02/06/使用-carrierwave-实现图片上传/","link":"","permalink":"http://yoursite.com/2018/02/06/使用-carrierwave-实现图片上传/","excerpt":"","text":"最近项目中需要实现头像上传功能的API接口，并且可以设置默认头像，这篇文章来大概总结一下具体的实现过程。 Rails中 实现图片上传最常用的是使用“gem carrierwave”。github 地址： carrierwave Step1 安装gem &quot;carrierwave&quot; gem &quot;mini_magick&quot; Step21rails g image uploader 这个命令会生成image_uploader.rb这个文件。之后关于图片的设置都需要在这个文件里设置。下面是我设置的配置文件。 12345678910111213141516171819202122232425262728293031 class ImageUploader &lt; CarrierWave::Uploader::Base include CarrierWave::MiniMagick storage :file def store_dir &quot;uploads/#&#123;model.class.to_s.underscore&#125;/#&#123;mounted_as&#125;/#&#123;model.id&#125;&quot; end# 设置图片大小，分为三个尺寸 process resize_to_fit: [800,800] version :thumb do process resize_to_fill: [200,200] end version :medium do process resize_to_fill: [400,400] end#设置图片的默认url地址，比如我要实现默认头像的设置，就会用到这个方法 def default_url(*args) &quot;/uploads/tbl_playerinfo/headimg/1/&quot; + [version_name, &quot;14563MHK40-13251.jpg&quot;].compact.join(&apos;_&apos;) end# 图片格式的设置 def extension_whitelist %w(jpg jpeg gif png) endend Step3设置model。table中的哪个字段存储图片就需要设置这个字段。1234class TblPlayerinfo &lt; ApplicationRecord # headimg 为存储用户头像的字段 mount_upload :headimg, ImageUploaderend Step4显示上传图片的url地址，代码如下：12345678910111213141516171819if @player.present? @gamer = @player.first json.code 0 json.msg &quot;已找到该玩家&quot; json.playerMsg do json.uid @gamer.userid json.name @gamer.nickname json.gold @gamer.gold json.online true json.sex @gamer.sex json.viptype @gamer.account.vip_type json.headimgurl @gamer.headimg_url json.score @gamer.score json.diamond @gamer.diamond endelse json.code 1 json.msg &quot;玩家不存在&quot;end 其中可以使用字段名加url后缀来直接显示图片的url地址。如headimg_url 总结：昨天一直想实现默认头像的功能，起初是在headimg这个字段设置默认值，但是捞出来的url总是错误的。后来仔细看了carrierwave的说明文档，才搞懂该如何设置默认的文件地址。教训：遇到问题要第一时间看官方文档和源代码，相比于在网络上寻找教程不仅可以提高自己的解决问题的效率，而且还能让自己养成看原始文档的好习惯。 补充：1234class TblPlayerinfo &lt; ApplicationRecord # headimg 为存储用户头像的字段 mount_upload :headimg, ImageUploaderend 其中headimg字段在数据库中的数据被记录为图片的名称。如果想要直接从数据库中直接获取完整的图片url地址，可以添加一个字段headimg2 用来代替headimg，然后headimg的值可以设置为服务器地址+headimg2, 例如12345678910111213if @player.update(:headimgxf =&gt; params[:image]) @player.update( :headimg =&gt; &quot;47.100.60.84&quot; + @player.headimgxf.to_s ) json.code 0 json.msg &quot;上传成功&quot; json.playerMsg do json.uid @player.userid json.name @player.nickname json.headimgurl @player.headimg endelse json.code 1 json.msg &quot;上传失败&quot;end 这样从数据库中捞取headimg字段的数据时就是完整的url地址了。","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"carrierwave","slug":"carrierwave","permalink":"http://yoursite.com/tags/carrierwave/"},{"name":"图片上传","slug":"图片上传","permalink":"http://yoursite.com/tags/图片上传/"}]},{"title":"Rails 中的数据查询方法","slug":"Rails-中的数据查询方法","date":"2018-02-06T09:30:51.000Z","updated":"2018-02-07T09:00:22.665Z","comments":true,"path":"2018/02/06/Rails-中的数据查询方法/","link":"","permalink":"http://yoursite.com/2018/02/06/Rails-中的数据查询方法/","excerpt":"","text":"Rails中的Acvtice Record使得我们不用写SQL语句就可以查询数据库中的数据。当使用Rails中的方法查询数据时，过程大体是这样的： 将查询选项转为sql语句 触发sql语句在数据库中查询 将查询结果实例化（变成对应的模型对象） 1– 查询单个对象（1）find方法find方法用于查询指定主键的对象；Author.find(1) （2） find_by方法find_by 方法会查询到符合条件的第一条记录Author.find_by(:name =&gt; &quot;鲁迅&quot;) 也可以写成Author.find_by name: &quot;鲁迅&quot; （3）take方法take方法会查询到一条记录，往往是数据表中的第一条记录。Author.take 2– 查询多个对象我们常常使用each方法，用来检索数据表中的记录。它的原理是会让Active Record 捞出整个数据表的数据，然后对每条记录创建模型对象，并把整个模型对象以数组形式保存在内存中。如果数据量很多的话，这样明显是行不通的。Rails有两种方法可以解决这个问题：（1）find_each工作原理：find_each方法每次检索一批记录，然后把每条记录实例化成模型对象传入块。默认每次检索1000条记录。123Player.find_each do |player| player.nameend a. 使用batch_size 来指定每次检索的记录总数123Player.find_each(batch_size: 5000) do |player| player.nameend b. 使用start 实现从起始点进行ID检索 ，比这个ID小的都不会取回。并且这个ID必须是主键。平常情况下较少用这个方法。1234# 检索id从10开始的作者姓名Player.find_each(start: 10) do |player| player.nameend c.使用finish 实现从起始点进行ID检索，比这个ID大的都不取回。与start类似。1234# 检索id为10000到20000的作者姓名Player.find_each(start: 10000, finish: 20000) do |player| player.nameend （2）find_in_batches工作原理：find_in_batches 方法每次检索一批记录，然后把每批记录实例化成模型数组传入块。用法和find_each 类似。 3.条件查询（1）数组条件中的占位符a. ?123$ Player.where(&quot;age &gt;= ?&quot;, params[:age])或者$ Player.where(&quot;player.age &gt;= ?&quot;, params[:age]) b. 字符如果条件中有很多变量，那么以下做法会更易于代码的阅读。1$ Player.where(&quot;age &gt;= :age AND saler &gt;= :wage_level_&quot;, &#123; age: params[:age], wage_level: params[:wage_level]&#125;) （2）使用not 反向查询查询年龄在30岁以上的玩家123$ Player.where(&quot;diamond &gt; ?&quot;, 30)也可以写成$ Player.where.not(&quot; diamond &lt;= ?&quot;, 30) 4. 查询特定字段使用find、find_by、where方法时会返回table的全部字段，若想返回指定的字段可以使用select ，比如查询年龄大于20 的玩家名字。（1） select方法12345Player.select(:name).where(&quot;age &gt;= ?&quot;, 30)查询名字和idPlayer.select(:userid, :name).where(&quot;age &gt;= ?&quot;, 30)&amp;Player.select(&quot;userid, name&quot;).where(&quot;age &gt;= ?&quot;, 30) （2）pluck方法pluck 方法与select方法不同，select返回是一组对象模型，pluck方法是返回字段数组，因此在数据量很大的情况下使用pluck会好很多。123456Player.select(:nickname, :userid).map&#123; |u| [u.userid, u.nickname]&#125;相当于Player.pluck(:nickname, :userid)PS:map 的另一种写法Player.select(:userid).map(&amp;:userid) pluck方法会触发即时查询，个人理解为立即查询，所以当其他查询在pluck之前时，会执行成功；在pluck之后时，会查询失败。例如:123Player.pluck(:userid).limit(5) #=&gt; undefined method `limitPlayer.limit(5).pluck(:userid) #=&gt; [1], [2], [3], [4], [5] （3）ids方法ids方法会获得模型的主键，rails中模型主键默认为id，返回的是数组。1234567891011class Player &lt; ApplicationRecord self.primary_key = &quot;userid&quot;endPlayer.ids相当于Player.pluck(:userid)或Player.select(:id).map(&amp;:userid)或Player.select(:id).map&#123; |u| u.userid&#125; 5.关联查询（1） joins 方法示例代码：1234567class Player &lt; ApplicationRecord has_many :groups, class_name: &quot;GroupMsg&quot;, foreign_key: &quot;userid&quot;endclass GroupMsg &lt; ApplicationRecord belongs_to :owner, class_name: &quot;Player&quot;, foreign_key: &quot;userid&quot;end 1$ GroupMsg.joins(:owner) 这条语句的意思为所有属于某个用户的圈子作为一个GroupMsg对象返回。123$ GroupMsg.joins(:owner).where(:userid =&gt; 2)查询结果相当于$ Player.find_by(userid: 2).groups 1$ Player.joins(:groups) 这条语句的意思为查询所有创建了圈子的用户作为Player对象返回（可以简单理解为查询创建过圈子的用户）。如果一个用户创建了很多圈子，那么也会被重复列出。 （2）includes方法includes可以解决N+1queries问题，因为它可以及早加载关联。1Player.includes(:groups) 这条命令会取出所有的用户和所有的关联圈子。对应的SQL语句为123#=&gt; 假设只有五个用户select * from playersselect * from group_msgs where group_msgs.userid in (1,2,3,4,5) 1GroupMsg.includes(:owner) 这个命令会捞出所有的圈子和相关联的用户。对应的SQL语句为12select * from group_msgselect * from players where player.userid = [2,3,4]","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"find find_by","slug":"find-find-by","permalink":"http://yoursite.com/tags/find-find-by/"},{"name":"where","slug":"where","permalink":"http://yoursite.com/tags/where/"},{"name":"select","slug":"select","permalink":"http://yoursite.com/tags/select/"}]},{"title":"Ruby 基础--学习笔记","slug":"Ruby-基础-学习笔记","date":"2018-02-02T09:22:17.000Z","updated":"2018-02-08T13:34:02.665Z","comments":true,"path":"2018/02/02/Ruby-基础-学习笔记/","link":"","permalink":"http://yoursite.com/2018/02/02/Ruby-基础-学习笔记/","excerpt":"","text":"1。each、map与collect(1)each方法是典型的迭代器，它的作用是可以遍历数组中的所有元素，并对其进行处理，但不改变原数组的值，返回结果也是原数组的值。123456sum = 0a = [1,2,3,4,5]a.each do |item| sum+=itemendprint sum #=&gt; 15 123a = [1,2,3,4,5]a.each&#123; |item| item*2&#125; #=&gt; [1,2,3,4,5]a #=&gt; [1,2,3,4,5] (2) 使用map与collect方法会形成一个新数组，原数组的值不变。123456789a = [1,2,3,4,5]a.each&#123; |item| item*2&#125; #=&gt; [1,2,3,4,5]a #=&gt; [1,2,3,4,5]a.map&#123; |item| item*2&#125; #=&gt;[2,4,6,8,10]a #=&gt; [1,2,3,4,5]a.collect&#123; |item| item*2&#125; #=&gt; [2,4,6,8,10]a #=&gt; [1,2,3,4,5] (3)使用map!与collect!会形成一个新的数组，并改变原数组的值。123456a = [1,2,3,4,5]a.map!&#123; |item| item*2&#125; #=&gt; [2,4,6,8,10]a #=&gt; [2,4,6,8,10]a.collect!&#123; |item| item*2&#125; #=&gt; [2,4,6,8,10]a #=&gt; [2,4,6,8,10] 2。作用域（1）作用域门12345678910111213v1 = 1class Myclass v2 = 2 local_variables #=&gt; [:v2] def my_method v3 = 3 local_variables end local_variables #=&gt; [:v2]endobj = Myclass.newobj.my_method #=&gt; [:v3] 当进行类定义（关键字：class）、模块定义(module)、方法定义（def）会产生作用域。 （2）穿越作用域1234567891011var = &quot;scope&quot;class Myclass puts &quot;#&#123;var&#125;&quot; def my_method endend#=&gt; NameError: undefined local variable or method `var&apos; for Myclass:Class得： 局部变量无法穿过Myclass的作用域 12345678910111213var = &quot;scope&quot;Myclass = Class.new do puts &quot;#&#123;var&#125; in the #&#123;self.class&#125;&quot; def my_method puts &quot;#&#123;var&#125;&quot; endend#=&gt; scope in the Class#=&gt; undefined local variable or method `my_var&apos; for Myclass:Class (NameError)得：(1)通过方法调用可以让局部变量穿过Myclass的作用域;(2)局部变量var无法穿过my_method的作用域。 12345678910111213var = &quot;scope&quot;Myclass = Class.new do puts &quot;#&#123;var&#125; in the #&#123;self.class&#125;&quot; define_method :my_method do puts &quot;#&#123;var&#125; in the #&#123;self.class&#125;&quot; endendobj = Myclass.newobj.my_method#=&gt; scope in the Class#=&gt; scope in the Myclass 3. 单引号和多引号的区别Ruby中生成字符串有两种方式，单引号和双引号，其中单引号不被转义，多引号会被转义。12$ name = &quot;jonathan&quot; # =&gt; &quot;jonathan&quot;$ string = &quot;#&#123;name&#125;&quot; # =&gt; &quot;jonathan&quot; 12$ name = &apos;jonathan&apos; # =&gt; &quot;jonathan&quot;$ string = &apos;#&#123;name&#125;&apos; # =&gt; &quot;\\#&#123;name&#125;&quot; 4. Symbol在散列中会常常用到符号（Symbol）。例如address = { :name =&gt; &quot;joanathan&quot;, :phone =&gt; &quot;123456&quot;} 其中:name :phone 就是符号。符号可以和字符串相互转换。12345name = :jonathan #=&gt; :jonathan等同于 name = :&quot;jonathan&quot;name1 = name.to_s #=&gt; &quot;jonathan&quot;name1.to_sym #=&gt; :jonathan 5. Ruby中的实例变量（1）Ruby中的对象包含实例变量，如果想要对象中的实例变量，需要调用对象的方法。示例代码：1234567891011121314class Person def name @name = &quot;Tim&quot; end def name=(vaule) @name = vaule end def kill @killer = name endend 下面就来做些小实验来验证需要调用方法才能访问对象中的实例变量。123tim = Person.newputs tim.name #=&gt; &quot;Tim&quot;puts tim.instance_variables #=&gt; [:@name] 此时没有调用kill方法，所以在tim这个对象调用instance_variables这个方法时没有@killer这个实例变量 1234tim = Person.newputs time.name #=&gt; &quot;Tim&quot;puts tim.killer #=&gt; &quot;Tim&quot;puts tim.instance_variables #=&gt; [:@name, :@killer] 12Tim = Person.newputs Time.name = &quot;Jonathan&quot; #=&gt; &quot;Jonathan&quot; 由此得知：Ruby如果想要访问对象中的实例变量或对其赋值，那么就需要调用对象的方法。（2）存取器存取器的定义为attr_accessor ，例如1234567891011121314class Person attr_accessor :nameend相当于class Person def name @name = &quot;Tim&quot; end def name=(vaule) @name = vaule endend 123tim = Person.newp tim.name = &quot;Jonathan&quot; #=&gt; &quot;Jonathan&quot;p tim.name #=&gt; &quot;Jonathan&quot; 123tim = Person.newp tim.name #=&gt; nil 因为@name的值为空p tim.name = &quot;Joanthan&quot; #=&gt; &quot;Jonathan&quot; 6. &lt;&lt; 符号在数组中，经常会用到 &lt;&lt;，示例代码:123ary = [1,2,3]ary &lt;&lt; 4ary = [1,2,3,4]","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"}]},{"title":"Ruby 中的 self","slug":"Ruby-中的-self","date":"2018-02-02T02:56:51.000Z","updated":"2018-02-02T04:39:03.054Z","comments":true,"path":"2018/02/02/Ruby-中的-self/","link":"","permalink":"http://yoursite.com/2018/02/02/Ruby-中的-self/","excerpt":"","text":"self 指的是当前对象。在调用方法时，分为两个步骤，查找方法和执行方法，调用方法的对象成为接收者，也就是当前对象。没有哪个对象可以一直充当当前对象的角色，并且，任何时刻，只有一个对象充当当前对象。 一. self 的含义1。在class关键字（类）内部，self指的是类本身。1234class Myclassputs selfend# Myclass 2。def 定义的方法内部，self指的是调用这个方法的对象（当前对象）1234567class Myclassdef my_method pust selfendend$ obj = Myclass.new #=&gt; #&lt;Myclass:0x007f90ee0e1830&gt;$ obj.method #=&gt; #&lt;Myclass:0x007f90ee0e1830&gt; 3。 self写在def关键字的后面，self指的是类本身12345678910class Myclassdef self.my_method puts selfendend$ obj = Myclass.new #=&gt; #&lt;Myclass:0x007fe83294de88&gt;$ obj.my_method #=&gt; NoMethodError: undefined method `my_method&apos; for #&lt;Myclass:0x007fe83294de88&gt;$ Myclass.my_method #=&gt; Myclass 由此可见，当self出现在def关键字后面时，self指的是Myclass这个类，而非Myclass类的实例obj。 二. 显式self与隐式self《ruby元编程》中提到私有规则：私有方法只能通过阴性的接收者调用。另：当一个对象被创建时，那么它就获得了它所属类中的实例方法。1。 ruby中定义的方法不特殊说明时，默认为public方法。123456789101112131415161718192021222324class Apublic #可省略def method1 puts &quot;I am method1&quot; self.method2enddef method2 puts &quot;I am method2&quot;enddef method3puts &quot;I am method3&quot;method2endend$ obj = A.new$ obj.method1#=&gt; I am method1#=&gt; I am method2$ obj.method3#=&gt; I am method3#=&gt; I am method2 2。 private 定义私有方法123456789101112131415161718192021222324252627class Apublic #可省略def method1 puts &quot;I am method1&quot; self.method3enddef method2 puts &quot;I am method2&quot; method3endprivatedef method3puts &quot;I am method3&quot;endend$ obj = A.new$ obj.method3 #=&gt; private method `method3&apos; called for #&lt;A:0x007fc1c9111f60&gt; (NoMethodError)$ obj.method1 #=&gt; private method `method3&apos; called for #&lt;A:0x007f8f9e822230&gt; (NoMethodError)$ obj.method2#=&gt; I am method2#=&gt; I am method3 由此得知，调用私有方法时不能明确指定接收者是谁，也就是只有隐性的接受者才能调用私有方法。 三. 方法访问级别1。private 与 protected1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Fatherdef method_a puts &quot;I am METHOD A in #&#123;self.class&#125;&quot;enddef method_b puts &quot;I am METHOD B in #&#123;self.class&#125;&quot; self.method_c #self 可以省略endprotecteddef method_c puts &quot;I am METHOD C in #&#123;self.class&#125;&quot;endprivatedef method_secret puts &quot;I am method_secret in #&#123;self.class&#125;&quot;endendclass Son &lt; Fatherdef son_method_c method_cenddef son_method_d self.method_cenddef son_method_secret self.method_secretendend$ son = Son.new$ son.son_method_c #=&gt; I am METHOD C in Son$ son.son_method_d #=&gt; I am METHOD C in Son$ son.son_method_b#=&gt; I am METHOD B in Father#=&gt; I am METHOD C in Father$ son.method_c #=&gt; NoMethodError: protected method `method_c&apos; called for$ son.method_secret #=&gt; NoMethodError: private method `method_secret&apos; called for$ son.son_method_secret #=&gt; NoMethodError: private method `method_secret&apos; called for$ father = Father.new$ father.method_c #=&gt; NoMethodError: protected method `method_c&apos; called for 由此得知：（1）在调用protected和private级别的方法时，不管是同类的对象（father）还是子类的对象（son），都不能够对其直接调用；只能通过其他方式，比如在别的方法中引用。（2）ruby中的私有方法只能被阴性self调用；public方法和protected方法可被显示self和隐式self调用。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"self","slug":"self","permalink":"http://yoursite.com/tags/self/"}]},{"title":"Rails生成乱数ID的实现方法","slug":"Rails生成乱数ID的实现方法","date":"2018-01-08T12:40:02.000Z","updated":"2018-01-08T12:59:45.305Z","comments":true,"path":"2018/01/08/Rails生成乱数ID的实现方法/","link":"","permalink":"http://yoursite.com/2018/01/08/Rails生成乱数ID的实现方法/","excerpt":"","text":"在ROR网站开发中，当我们查询某笔资料时，一般情况下，网址是这样的，如下图： 这样做的缺陷很明显，就是用户可以通过网址猜到我们数据库中user的数据量。为了解决这个问题，我们可以通过把ID改成乱数ID的形式解决，就像下面这样： 实现过程如下： step1：model层的实现1- 为 user添加friendly_id 字段1$ rails g migration add_friendly_id_to_users 2- 在新生成的migration文件中，为friendly_id 添加唯一索引12add_column :users, :friendly_id, :stringadd_index :users, :friendly_id, :unique =&gt; true 1$ rake db:migrate 3- 修改user.model123456789before_validation :generate_friendly_id, on: :createdef to_param self.friendly_idenddef generate_friendly_id self.friendly_id ||= SecureRandom.uuidend 其中to_param Rails中自带的方法，我们在这里对它进行重新定义。之前的定义为，123def to_param self.idend 它的作用转换ID，例如user_path(current_user) 就相当于 user_path(current_user.to_param) ,也相当于 user_path(current_user.id)。 Step 2 controller层通常我们的users_controller.rb 会是这样123456789101112131415161718192021222324Class UsersController &lt; ApplicationController# 事例代码 before_action :find_user, only: [:show, :edit, :update] def show end def edit end def update if @user.update flash[:notice] = &quot;更新成功&quot; redirect_to users_path else render &apos;edit&apos; end private def find_user @user = User.find(params[:id]) endend 我们对其中的 find_user这个方法 做如下修改 123def @user = User.find_by_friendly_id!(params[:id])end 到这里就可以实现乱数ID的显示了。 豆知识补充1- “||= ” 符号a ||= b 相当于 a = a || b ，它的意思为当a的值为nil时，将b的值付给a。例如 上面提到过的self.friendly_id ||= SecureRandom.uuid， 当self.friendly_id的值为空时，将SecureRandom.uuid赋值给它。","categories":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/categories/Rails/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"乱数ID","slug":"乱数ID","permalink":"http://yoursite.com/tags/乱数ID/"}]},{"title":"数据库的工作原理（一）","slug":"数据库的工作原理（一）","date":"2018-01-08T06:36:24.000Z","updated":"2018-01-08T06:38:09.407Z","comments":true,"path":"2018/01/08/数据库的工作原理（一）/","link":"","permalink":"http://yoursite.com/2018/01/08/数据库的工作原理（一）/","excerpt":"","text":"开始之前的说明：最近在学习数据库的相关知识，找到了一篇很好的学习文章，写的蛮深入，同样内容也很长，所以理解起来有些难度。为了让自己更好的理解数据库的工作原理，我把自己对这篇文章的理解，写成了这篇博客（共计三篇），旨在提高自己的学习效果。原文地址：http://blog.jobbole.com/100349/。 前言：在了解数据库是如何工作的内容之前，需要知道一些基本概念。在很久以前，开发人员需要把常用的算法和数据结构牢记于心，因为当时计算机的处理能力较差，无法承受对cpu的浪费。研究数据结构和算法的目的，或者说选择哪个数据结构和算法，是为了以更快的速度得到数据处理的结果。判断一个算法优劣的因素大体上有三个：（1）时间复杂度（2）算法的内存消耗（3）算法磁盘I/O消耗这里主要介绍时间复杂度的概念。PS：《数据库工作原理（一）》主要梳理相关的基础概念。 一、 时间复杂度时间复杂度指的是某个算法处理一定量数据所要消耗的时间。这个时间我们无法进行准确的计算，但是可以通过“某个算法处理一定量的数据需要多少次运算”来间接的判断算法的优劣。这里我们使用O(某函数)这样的方式来表示某个算法处理一定量的数据进行的运算次数，所需的运算次数即函数计算出的值，比如像下面这样。假设有1000000笔数据，各个算法的运算次数如下： O(1) 算法会消耗 1 次运算 O(log(n)) 算法会消耗 14 次运算 O(n) 算法会消耗 1,000,000 次运算 O(n*log(n)) 算法会消耗 14,000,000 次运算 O(n^2) 算法会消耗 1,000,000,000,000 次运算 这样我们就很容易得知，O（1）算法是我们首要选择的，O(n^2)是我们绝不会选择的算法。 了解了时间复杂度的概念以及如何表示时间复杂度后，接下来的内容会容易理解很多，比如： 一个好的哈希表会得到O(1)复杂度，这是最理想的状态 一个均衡的树会得到O(log(n))复杂度，其中n代表数据量，即要处理数据的数量大小 一个阵列会得到O(n)复杂度 最好的排序算法具有O(n*log(n))复杂度 糟糕的排序算法具有O(n^2)复杂度。 这里的哈希表、B树、阵列，它们是不同的数据结构。根据他们能够得到的时间复杂的不同，我们当然会尽可能选择时间复杂度低的那一个。 二、数据结构 数据结构可以类比为房屋结构，就像不同屋子有不同的结构一样，每种不同的房屋结构会有不同的用途。比如工业厂房会很大，而且比较空旷，用于进行工业生产；写字楼的结构比较复杂，用于人们上班办公；居民房的结构相比会小一些，用于居住等。数据结构也一样，不同的数据结构有不同的适用场景，我们不能直接评论数据结构的好坏之分，但是会有一个评判标准，就是处理数据的速度。 如上所说的一样，不同的房屋结构适用于不同场景。数据结构也一样，有的数据结构善于处理这种情况，有的数据结构善于处理那种情况。例如： 阵列，用于数据量比较小的情况，它的时间复杂度为 O(n) 树，善于处理“查找一个确定值”的情况，它的时间复杂度为O(log(n))，树是阵列的优化。 B树，善于处理“查找范围值”的情况，它需要消耗 M+log(N)次运算 哈希表，用于快速查找某个值。 数据结构是数据库内部的基本组件。 三、数据库概览数据库说白了，其实是一堆文件的集合，一个信息集合，对这一堆文件进行精心的设计就是数据库干的工作。比如可以快速处理数据（如查询），使用事务来保证数据的安全和唯一性等。 数据库是信息的集合，那么可以把它想象成数据的仓库。既然是仓库，那么就需要管理，管理就需要工具，数据库的各种组件就属于是工具，他们用来管理这个大仓库中的不同事务。这张图上列出了数据库内的各组件。包括客户端管理器、查询管理器、数据管理器等。 下一篇将会着重介绍数据库的一个很重要的管理器–查询管理器。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"http://yoursite.com/tags/时间复杂度/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"}]},{"title":"Rails项目部署","slug":"Rails项目部署","date":"2018-01-06T07:47:04.000Z","updated":"2018-01-08T01:32:15.219Z","comments":true,"path":"2018/01/06/Rails项目部署/","link":"","permalink":"http://yoursite.com/2018/01/06/Rails项目部署/","excerpt":"","text":"基本配置： （1）服务器类型：阿里云服务器 （2）镜像系统：Ubuntu 16.04 64位 （3）web服务器： Nginx + Passenger （4）数据库服务器：MySQl 基本知识： 基本CLI指令。date 会显示系统时间uname -a 显示系统版本uptime 查电脑开机多久了which 查询执行档的确切位置history 查询刚刚执行过的指令 vi 、nano、vim是三种文档编辑器，nano与vim是操作系统内建的。 传档案：SSH 通信协议除了可以让我们登入远端的服务器，也可以作为档案传输使用，又叫做 SFTP。例如： 1scp test.txt root@106.14.190.181:~/ 这个命令的意思是将本机的test.txt文件传到服务器上root账号的 ~/ 文件夹下； 1scp root@106.14.190.181:~/test.txt ./ 这个命令的意思是将服务器上的text.txt 文件传到本机 压缩与打包：如果要向服务器传很多档案，那么使用压缩打包的方式会很快；压缩和打包是可以分开的：gzip 只能压缩一个档案、tar 可以打包整个目录顺便压缩。 gzip 压缩档案 gzip -d 解压缩档案 tar zcvf xxx.tar.gz xxx将 xxx目录打包并压缩成 xxx.tar.gz 档案 tar zxcf xxx.tar.gz 将 xxx.tar.gz 解压缩 一、更新并安装Linux套件apt-get 是Ubuntu内建的套件管理工具。拿到一台服务器，首选应该做的是更新上面的套件。1- 执行 pt-get update 。 2- 执行 apt-get upgrade -f 。 3- 设定时区：dpkg-reconfigure tzdata,进入菜单后选择Shanghai。 4- 安装Ruby on Rails所需 的东西：1apt-get install -y build-essential git-core bison openssl libreadline6-dev curl zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 autoconf libc6-dev libpcre3-dev libcurl4-nss-dev libxml2-dev libxslt-dev imagemagick nodejs libffi-dev 二、安装Ruby使用Brighbox编译好的Ruby套件进行安装。1- 执行 apt-get install software-properties-common 2- 执行 apt-add-repository ppa:brightbox/ruby-ng 3- 执行 apt-get update 4- 执行 apt-get install ruby2.4 ruby2.4-dev 执行完上面四个命令后，执行 ruby -v检查ruby是否成功安装5- 安装Bundler，执行gem install bundler --no-ri --no-rdoc --source https://gems.ruby-china.org 三、安装MySQL1- 执行 sudo apt-get install mysql-common mysql-client libmysqlclient-dev mysql-server，然后根据提示设置登录密码 2- 执行mysql -u root -p 登录数据库，输入CREATE DATABSE your-database-name CHARACTER SET utf8mb4 四、安装Nginx + PassengerNginx是目前很流行的一种网站服务器，我们用它来处理静态资源，例如CSS/JS;Passenger 是一个 app server，支持基于 Rack 框架的 Ruby app（包括 Rails）。Passenger 的特点是需要作为模块编译到 Nginx 中，优点是配置简单，不需要自己写启动脚本。以下是安装步骤： 1- 通过apt安装Passenger，这里需要导入Passenger密钥1apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 561F9B9CAC40B2F7 2- 安装apt插件以支持http传输1apt-get install -y apt-transport-https ca-certificates 3- 添加apt的源1sh -c &apos;echo deb https://oss-binaries.phusionpassenger.com/apt/passenger xenial main &gt; /etc/apt/sources.list.d/passenger.list’ 之后执行 apt-get update 4- 安装Passenger的包1apt-get install -y nginx-extras passenger 修改Nginx配置，编辑/etc/nginx/nginx.conf改为下面这样：123456789101112131415161718192021222324252627282930313233343536 # 让 Nginx 可以读到环境变量 PATH，Rails 需要这一行才能调用到 nodejs 来编译静态档案。+ env PATH; user www-data; worker_processes auto; pid /run/nginx.pid; events &#123; worker_connections 768; # multi_accept on; &#125; http &#123; # 关闭 Passenger 和 Nginx 在 HTTP Response Header 的版本资讯，减少资讯洩漏+ passenger_show_version_in_header off;+ server_tokens off; # 设定档案上传可以到100mb，默认只有1Mb超小气的，上传一张图片就爆了+ client_max_body_size 100m; gzip on; gzip_disable &quot;msie6&quot;; # 最佳化 gzip 压缩+ gzip_comp_level 5;+ gzip_min_length 256;+ gzip_proxied any;+ gzip_vary on;+ gzip_types application/atom+xml application/javascript application/x-javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/xml text/plain text/javascript text/x-component; # 打开 passenger 模组- # include /etc/nginx/passenger.conf;+ include /etc/nginx/passenger.conf; # 下略 新增/etc/nginx/sites-enabled/example.conf1234567891011121314151617server &#123; listen 80; server_name 47.92.82.116; # 你的服务器 IP 位置 root /home/deploy/example/current/public; # example改为你自己的项目名称 passenger_enabled on; passenger_min_instances 1; location ~ ^/assets/ &#123; expires 1y; add_header Cache-Control public; add_header ETag &quot;&quot;; break; &#125;&#125; 完成Nginx的设定之后，执行 service nginx restart。 此时使用你的Ip地址打开网页如下图： 五、 安装Capistrano自动化部署1- 本机安装gem &#39;capistrano-rails&#39;与 gem &#39;capistrano-passenger &#39; 2- capistrano 文件设定 执行 cap install ，新增capistrano 的配置档案，编辑以下文件： （1）Capfile 1234require &quot;capistrano/scm/git”install_plugin Capistrano::SCM::Git+ require &apos;capistrano/rails’+ require &apos;capistrano/passenger’ （2）config/deploy.rb1234567891011121314151617181920212223242526272829303132333435363738394041424344+ sh &quot;ssh-add&quot; # config valid only for current version of Capistrano lock &quot;3.8.1&quot;- set :application, &quot;my_app_name&quot;+ set :application, &quot;rails_recipes&quot; # 请用你自己的项目名称- set :repo_url, &quot;git@example.com:me/my_repo.git&quot;+ set :repo_url, &quot;git@github.com:growthschool/rails-recipes.git&quot; # 请用你自己项目的git位置 # Default branch is :master # ask :branch, `git rev-parse --abbrev-ref HEAD`.chomp # Default deploy_to directory is /var/www/my_app_name # set :deploy_to, &quot;/var/www/my_app_name&quot;+ set :deploy_to, &quot;/home/deploy/rails-recipes&quot; # 这样服务器上代码的目录位置，放在 deploy 帐号下。请用你自己的项目名称。 # Default value for :format is :airbrussh. # set :format, :airbrussh # You can configure the Airbrussh format using :format_options. # These are the defaults. # set :format_options, command_output: true, log_file: &quot;log/capistrano.log&quot;, color: :auto, truncate: :auto # Default value for :pty is false # set :pty, true # Default value for :linked_files is []- # append :linked_files, &quot;config/database.yml&quot;, &quot;config/secrets.yml&quot;+ append :linked_files, &quot;config/database.yml&quot;, &quot;config/secrets.yml&quot; # Default value for linked_dirs is []- # append :linked_dirs, &quot;log&quot;, &quot;tmp/pids&quot;, &quot;tmp/cache&quot;, &quot;tmp/sockets&quot;, &quot;public/system&quot;+ append :linked_dirs, &quot;log&quot;, &quot;tmp/pids&quot;, &quot;tmp/cache&quot;, &quot;tmp/sockets&quot;, &quot;public/system&quot;+ set :passenger_restart_with_touch, true # Default value for default_env is &#123;&#125; # set :default_env, &#123; path: &quot;/opt/ruby/bin:$PATH&quot; &#125; # Default value for keep_releases is 5- # set :keep_releases, 5+ set :keep_releases, 5 (3) config/deploy/production.rb123+ set :branch, &quot;master&quot;- # server &quot;example.com&quot;, user: &quot;deploy&quot;, roles: %w&#123;app db web&#125;, my_property: :my_value+ server &quot;47.92.82.116&quot;, user: &quot;deploy&quot;, roles: %w&#123;app db web&#125;, my_property: :my_value, 其中user为你自己设定的用户名称 之后的步骤是根据cap production deploy:check检查缺少哪些文件，按照提示新增缺少的文件即可，一般需新增database.yml与secrets.yml这两个个文件。 最后在本机执行 cap production deploy ,完成部署。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"http://yoursite.com/tags/Rails/"},{"name":"Rails部署","slug":"Rails部署","permalink":"http://yoursite.com/tags/Rails部署/"},{"name":"Ubuntu + Nginx + Passenger","slug":"Ubuntu-Nginx-Passenger","permalink":"http://yoursite.com/tags/Ubuntu-Nginx-Passenger/"}]},{"title":"SQL基础","slug":"SQL基础","date":"2018-01-04T07:09:29.000Z","updated":"2018-01-05T01:25:25.483Z","comments":true,"path":"2018/01/04/SQL基础/","link":"","permalink":"http://yoursite.com/2018/01/04/SQL基础/","excerpt":"","text":"SQL，Structure Query Language，结构化查询语言，是关系型数据库的应用语言。 一、分类 DDL（Data Defintion Language ）语句：数据定义语言，定义了不同的数据段、数据库、表、列、索引等数据库对象，常用的语句的关键字包括 create、drop、alter等。 DML（Data Manipulation Language）语句：数据操纵语句，用于增删改查数据库记录，并检查数据的完整性。关键词： insert、delete、update、select。 DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的许可。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。关键词：grant、revoke。 二、DDL语句 DDL语句一般情况下是由数据库管理员（DBA）使用，与DML的最大区别是DML只对表内数据进行操作，而不设计表的定义、结构和修改。以下命令均为在指定数据库内操作，因此不用指明是在哪里数据库里新增等，若没有指定，则需要加上数据库的名称。 创建数据库 - CREATE DATABASE dbname; （CREATE DATABASE 也可小写 ） 删除数据库 - DROP DATABASE dbname； 创建表 - 1234CREATE TABLE tablename（ column_name_1 column_type_1_constraints, column_name_2 column_type_2_constraints, ... column_name_n column_type_n_constraints） 查看表结构 —— DESC tablename 更全面地查看表定义 —— show create table tablename \\G; 这条命令可以看到创建表的SQL语句,其中“\\G”的意思是使得记录能够按照字段竖向排列，也就是改变我们看到的格式。 删除表 - DROP TABLE tablename 修改表- 修改表类型（字段的类型）1ALTER TABLE tablename MODIFY[COLUMN] column_definition [FIRST|AFTER col_name] 例如，在mysql环境下执行，alter table emp modify ename varchar(20)。 增加表字段 1ALTER TABLE table_name ADD[COLUMN] column_definition [FIRST|AFTER col_name] 例如， alter table emp add column age int(3); 删除表字段 -ALTER TABLE table_name DROP [COLUMN] col_name;例如， alter table emp drop column age； 字段改名 -1ALTER TABLE table_name CHANGE[COLUMN] old_col_name column_definition[FIRST|AFTER column_name] 例如，alter table emp change age age1 int(4);PS: chang与modify都可以修改列，但是change即可以修改列的名称，也可以修改列的类型，而modify只能修改列的类型。 修改字段的顺序 -例如，alter table emp add age int(2) after name; alter table emp change age age1 int(4) first; 修改表名 -ALTER TABLE table_name RENAME [TO] new_tablename,例如， alter table emp rename emp1; 三、DML 语句DML语句是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。 1- 插入记录插入单条记录：INSERT INTO table_name(field1, field2, … fieldn) VALUES(value1, value2, …valuen);例如，insert into emp(ename, hire,sal,deptno) values(‘zzx1’, ‘2000-1-1’, ‘2000’,1); 也可以不用指定字段名称，但是需要values后面的循序与字段的顺序一致。 插入多条记录：INSERT INTO tablename (field1, field2, … fieldn)VALUES(record1_value1, record2_value2, … record1_valuen),(record2_value1, record2_value2, … record2_valuen),…(recordn_value1, recordn_value2, … recordn_valuen);例如insert into dept VALUES(5, “35”),(3,”232”); 2- 更新记录更新记录：UPDATE tablename SET filed1= value1,field2= value2, … filedn=valuen [WHERE CONDITION],例如，`update emp set sal=4000 where ename=‘lisa’;`` 更新多个表中的记录：UPDATE t1,t2,…tn set t1.field=value1,tn.field=valuen [WHERE CONDITION] 3- 删除记录DELETE FROM tablename [WHERE CONDITION]例如，delete from emp where ename=‘lisa’; 删除多个表中的记录：DELETE t1,t2,..tn FROM t1,t2,…tn [WHERE CONDITION]PS: 不论是单表还是多表，不加where条件都会把表的所有记录删除； 4- 查询记录SELECT FROM tablename [WHERE CONDITION]例如,select from emp;,为查询emp这个表中的所有字段。如果想要部分字段的话，需要分别写出各个字段的名字，例如 select ename from emp; （1）查询重复记录用到“distinct”,例如 select distinct slaer from emp; （2）条件查询关键词：where，例如 select * from emp where name=Lisa;其中“=”也可以是&gt; &lt; &gt;= &lt;= != 多条件还可以使用or和and等逻辑运算符进行多条件联合查询。 （3）排列顺序和限制语法如下：SELECT * FROM tablename [WHERE CONDTION] [ORDER BY field1 [DESC/ASC],field2 [DESC/ASC],… fieldn [DESC/ASC]]。 不写关键字默认我ASC(升序排序)。ORDER BY 后面可以跟不同的字段，每个字段可以有不同的排序。 对于排序后的记录，如果只希望显示一部分，这时就需要用到LIMIT关键字。语法如下：SELECT … [LIMIT offset_start,row_count]。 例如select * from emp order by sal limit 3; select * from emp order by sal limit 1,3; limit 经常和 order by 一起配合使用来进行记录的分页显示。 （4）聚合 用于汇总操作，例如统计。语法如下：123456SELECT [field1,field2,…fieldn] fun_nameFROM tablename[WHERE where_condition][GROUP BY field1,field2,…fieldn [WITH ROLLUP]][HAVING where_condtion] 其中： fun_name 表示要做的聚合操作，也就是聚合函数，常用的有sum count max min GROUP BY 表示要进行分类聚合的字段，比如按照部分分类统计员工数量，部门就应该写在group by 后面 WITH ROLLUP是可选语法，表明是否对分类聚合后的结果进行再汇总 HAVING 表示对分类后的结果再进行条件的过滤。PS：having和where都是过滤，where是在聚合前过滤，having是对聚合后的结果过滤。 统计总人数： select count(1) from emp;统计各个部门的人数： select deptno,count(1) from emp group by deptno;既统计部门人数又统计总人数：select deptno.count(1) from emp group by deptno with rollup;统计部门人数大于1的部门： select deptno.count(1) from emp group by deptno having count(1)&gt;1;统计公司所有员工的公司薪水总额、最高和最低薪水：select sum(sal),max(sal),min(sal) from emp; （5）表连接表连接分为内连接和外链接，内连接仅仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录，最常用的是内连接。例如，查询所有雇员的名字和所在的部门名称，因为雇员名称和部门分别放在表emp、dept中，因此需要使用表连接来查询。select ename,deptno from emp,dept where emp.deptno=dept.deptno; （6）子查询某些情况下，当进行查询的时候，需要的条件是另外一个select语句的结果，这时就会用到子查询。关键字：in、not in、=、exists、not exists等,例如， select * from emp where deptno in(select deptno from dept)。PS：表连接在很多情况下用于优化子连接。 四、DCL语句DCL语句主要是DBA用来管理系统中的对象权限时使用，开发人员很少使用，例如1mysql &gt; grant all PRIVILEGES on db_name.* to 'username'@'xxx.xxx.xx.x' identified by 'password' WITH GRANT OPTION; grant 为放出权限，select为收回权限。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"SQL语句","slug":"SQL语句","permalink":"http://yoursite.com/tags/SQL语句/"}]},{"title":"数据库的事务与锁","slug":"数据库的事务与锁","date":"2018-01-03T07:15:58.000Z","updated":"2018-01-03T07:39:57.375Z","comments":true,"path":"2018/01/03/数据库的事务与锁/","link":"","permalink":"http://yoursite.com/2018/01/03/数据库的事务与锁/","excerpt":"","text":"学习数据库的事务与锁之前需要先了解下什么是并发： 多个用户对同一数据进行交互叫做并发。如果不加以控制，并发可能引起很多问题。数据库提供了可以合理解决并发问题的方案。 一、事务 事务的概念：类比于银行转账，A转给B100元，那么A的账户减少500，B的账户增加500元，这个两个操作必须全部执行，要么就全部不执行。数据库的的事务总是将指定的一条语句或多条语句看成一个全部执行或者全部不执行的最小组合全部组合。 事务类型：如SELECT INSERT UPDATE DELETE 1- 显示事务处理模式通过START TRANSACTION 标记事务起始点，如果开启事务后执行的语句是按照期望正确执行的则以COMMIT TRANSACTION 来结束事务；如果开始事务后执行的语句结果不是所期望的，并希望取消刚才的操作，则以ROLLBACK TRANSATION 来结束事务，（相当于撤销），该动作成为回滚。前滚指的是再次执行一次事务中的操作。 2- 自动提交事务模式默认情况下，MySQL是自动提交的。在该模式下，每条语句都被认为是一个事务。当每个SQL语句执行完成后，不是被提交就是被回滚，如果执行成功则提交，执行失败则回滚。注意：在该模式下，执行的语句如果出现编译错误（例如关键字错误）而非运行错误该批语句都不会执行，而不是执行后再回滚；如果是运行错误不会导致该批语句都不执行，而是错误语句会回滚，之前语句正常执行。 3-隐式事务处理模式可以通过 SET IMPLICIT_TRANSACTIONS ON 和 SET IMPLICIT_TRANSACTIONS OFF 来启动和关闭隐式模式。与显示事务处理模式相比，它省略了事务起始点，也就是START TRANSATION。 PS:事务也是可以嵌套的，这里不进行详细说明。 二、并发访问引起的问题并发：两个用户或者两个以上的用户在同一时间与同一对象进行交互。例如春节抢票，抢的人越多，并发数就越高，对系统性能要求就越高。 1- 丢失更新当两个或多个事务对同一数据最初的值进行更新时，由于每个事务都不知道其他事务的存在，最后提交的事务中的更新操作就会覆盖掉其他事务所做的更新，这就导致其他事务的更新操作丢失。 2- 脏读事务完成数据更新后，这时其他事务去查询该行数据的时候读取的数据是临时的，如果最后更新的事务被回滚，这个临时数据对于查询的事务来说就是“脏数据”。 3- 不可重复读在一个事务两次的查询之间，同一数据被其他事务更新，导致同一事务中的两次查询结果不同，这样的现象叫做不可重复读。确定的某条记录。 4- 幻影读一个事务中指定范围的两次查询结果因为其他事务更新了符合范围的数据，导致两次结果查询结果不同，这样的现象叫做幻影读。幻影读不仅仅只适用于符合条件的范围内的记录有多少，还适用于涉及到范围概念的情况。与范围数据有关。 三、锁锁，即锁定，在数据库的概念为：在哪些数据或者对象上获取了锁就对对应的数据或者对象进行了锁定，其他事务就无法获取和现有锁相冲突的锁。锁是事务用来保护与自己交互的数据或者对象不受其他事务干扰的机制，实现了事务与事务之间的隔离。正是因为锁的存在，才可以根据业务需求合理地解决并发访问带来的问题。 1- 锁的粒度与锁升级数据库可以在某一行获取锁，也可以对某一张表获取锁，也可以对整个数据库获取锁。这种多层次的锁结构成为锁的粒度。锁的粒度越粗，并发度越低，系统性能越高。下面可以申请锁的粒度类型： 行或行标识符（RID）：属于行级锁（InnoDB），用于锁定堆中某个行的行标识符。 键（Key）：属于行级锁，在索引的键上存放锁，用户保护事务中的键的范围。 页（Page）：锁定该页中的所有数据或键。 区（Excent）：锁定整个区段，包括里面的页以及页中的数据行和键。 表（Table）：锁定整个表以及与表关联的所有对象，如表中的数据行、索引键。 数据库（Database）：锁定整个数据库。 由低层次的锁升级到高层次的锁成为锁升级。 2- 锁的类型数据库引擎基于事务类型选择不同的锁，这些锁决定了并发事件访问资源的方式。此处只列出三种类型的锁。 （1）共享锁（S锁）共享锁用于只需要读取不需要进行修改或更新数据的操作，如SELECT语句就是一种最基本常见的申请共享锁的语句。共享锁避免了不可重复读与幻影读问题。 （2）独占锁（X锁）独占锁也成为排他锁。与其他所有的锁都冲突。当需要进行数据更改操作如INSERT、UPDATE、DELETE时，锁管理器就会分配X锁。一般情况下，数据修改时包含两个动作：读取需要的数据和修改数据，因此在数据修改时会申请共享锁和独占锁。在同一张表中修改数据，此时共享锁更应该成为更新锁，但是如果更新操作连接了其他表，那么其他表中就会存在共享锁，并在需要的数据上申请独占锁。 （3）更新锁（U锁）更新锁和共享锁兼容，和独占锁冲突。更新锁和更新锁也冲突。修改数据时会先申请更新锁后申请独占锁， 更新锁是一种过渡锁。在进行数据搜索时持有了更新锁，由于更新锁和共享锁兼容，因此此时其他事务是允许读取数据的，当确定修改数据后，更新锁等待其他事务的共享锁释放后就会转换为独占锁（那么等待时间如何计算？），并将其他事务的相关资源的锁申请全部队列化堵在数据修改的进程外，直到独占锁释放，其他事务才能进行相关资源的申请。 死锁：两个事务都在等待一个资源，但同时又相互阻止对方获取资源，这时就会发生死锁现象。例如，事务A和事务B都获取了某一行数据的共享锁（也就是可以查看该数据），当事务A想修改该数据时要将共享锁转化为独占锁，这就需要等待事务B释放共享锁，但是事务B也想修改数据，将共享锁转换为独占锁，它将等待事务A释放共享锁，这样两个事务之间形成了僵局。 更新锁和共享锁是兼容的，因此更新锁和共享锁可能在同一资源上相互共存，但是更新锁和更新锁是相互冲突的，所以只能有一个事务对数据有更新锁。在过度为独占锁前，只有更新锁的事务必须先等待其他事务释放所有的共享锁，这就避免了上述的死锁问题。 四、事务隔离级别在数据库系统中可以通过设置事务隔离级别间接地控制锁，实现事务之间的隔离，从而解决并发问题。事务隔离级别是并发控制的整体解决方案，其实质是通过控制锁来控制事务之间如何进行隔离。 1- 提交读（READ COMMITTED）查询申请的共享锁在语句执行完毕后就释放，不需要等待事务结束后释放；数据修改申请的独占锁一直持有，直到事务结束才释放。设置提交读，可以避免脏读问题，但是不能解决不可重复读和幻影读。 PS：设置事务隔离级别和查看。隔离级别的设置是对会话级别的，所以只对当前会话有效。 2- 可提交读（READ UNCOMMITTED）未提交读是控制级别最低的级别，设置之后，该会话的所有读操作将不申请共享锁，因此读时将忽略所有的锁，但是更新时仍然会申请独占锁，这种情况下并发带来的问题都有可能发生。 3- 可重复读（REPEATABLE READ）MySQL默认事务隔离级别，当设置为可重复读隔离级别时，除了独占锁会一直保持到事务结束，共享锁也一样到事务结束。可重复读隔离级别下，脏读、丢失的更新和不可重复读问题都能够避免，但是也因为共享锁一直持有，会导致其他事务不能对相关数据进行修改，降低了并发度和性能。可重复读隔离级别无法解决幻影读问题。 4- 串行化（SERIALIZABLE）串行化隔离级别隔离层次最高，它能够避免丢失的更新、脏读、不可重复读和幻影读问题。设置为串行化隔离级别后，共享锁也将一直持有到事务结束。比可重复读更严格的是它的锁定是范围的，还包括潜在的数据修改。它保证了范围内两次查询结果不会出现增加记录或减少记录而出现幻象。 串行化隔离级别对锁控制的方式为：如果在查询指定条件的列上有索引，则在该列符合条件的范围记录上加上KEY粒度的锁，如果在查询条件的列上没有索引，则直接在表上加上共享锁。 五、隔离级别、锁和并发问题的关系","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"数据库事务","slug":"数据库事务","permalink":"http://yoursite.com/tags/数据库事务/"},{"name":"数据库的锁","slug":"数据库的锁","permalink":"http://yoursite.com/tags/数据库的锁/"}]},{"title":"网络基础-HTTP","slug":"网络基础-HTTP","date":"2018-01-02T14:25:13.000Z","updated":"2018-01-02T15:10:39.828Z","comments":true,"path":"2018/01/02/网络基础-HTTP/","link":"","permalink":"http://yoursite.com/2018/01/02/网络基础-HTTP/","excerpt":"","text":"最近Rails项目部署的过程中遇到网络端口的问题及用到了http网络协议的知识，于是决定对这块知识进行回顾和重新梳理，这里推荐韩立刚老师的《计算机网络原理》一书，讲的很明白。以下为这次学习到的主要内容： HTTP( Hyper Text Transfer Protocol) WWW( World Wide Web),互联网上的网站共同组成万维网。 URL( Uniform Resource Locator)，统一资源定位符，网站的网址。URL一般由四个部分组成：&lt;协议&gt;://&lt;主机&gt;:&lt;/端口&gt;/&lt;路径&gt;，例如http://106.14.190.181:80/wx 一、HTTP协议版本：1- HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，既不跟踪每个客户也不记录过去的请求。 2- HTTP1.1支持持续连接，即服务器在发送响应后，仍然在一段时间内保持这条TCP连接，使得同一个浏览器和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。HTTP1.1的持续连接有两种工作方式，即非流水线方式和流水线方式。非流水线方式（理解为迅雷一次只能下载一个文件）的特点是客户在收到前一个响应后才能发送写一个请求。因此，在TCP连接建立后，客户每访问一次对象都要用去一个往返时间RTT，这种方式浪费服务器资源。流水线的特点（理解为迅雷一次可以下载多个文件）是客户在收到HTTP响应报文之前就能够发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文，这种方式使TCP连接中的空闲时间减少，提高了文档的下载效率。 3- HTTP请求报文与响应报文（1） 请求报文：从客户端向服务器发送请求报文 请求报文由三个部分组成：分别是请求行，首部行，实体主体。请求报文的第一行“请求行”只有三个内容，即方法、请求资源的URL，以及HTTP的版本。方法就是对对象的操作，HTTP1.1协议中定义了八中方法，来表明对Request-URL指定资源的不同操作方式：GET、POST、PUT、DELETE、HEAD、TRACE、CONNECT、OPPIONS（2）响应报文：从服务器到达客户端的应答 二、CookieHTTP是一种无状态的协议，当你注册登录一个网站后，当下次再打开这个网站后，需要再次输入账号与密码进行身份验证，服务器仅从网络连接上无从知道你的曾经登录的身份。如果希望服务器读取你的曾经登录的身份，那就需要在用户输入账号和密码后，服务器在用户的计算机存放一个通行证，来记录用户的身份和状态。以后再访问，网站（服务器）就会先读取客户端的通行证。服务器存放在客户端（浏览器）的通行证通常被称为cookie。 cookie实际上是一小段的文本信息（说明可以进行拷贝，也就是在其他浏览器导入cookie之后不用输入账号和密码就可以登录了）。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端把浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器吧请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份和状态。服务器还可以根据需要修改cookie的内容。 三、通过代理服务器访问网站代理服务器英文全称为Proxy Server，其功能就是代理网络用户去取得网络信息。我们可以配置计算机通过Web代理服务器访问Web站点，而不直接访问网站。 使用代理服务器的场景：（1）使用代理服务器，绕过防火墙封锁。国内不允许网民访问国外的非法网站，在我国的防火墙上设置了拦截到这些网站的流量。但是国外有很多的web代理服务器，国内用户可以设置浏览器使用国外的代理商服务器，然后访问非法网站，就能成功。现在有很多“翻墙”软件，其实质就是使用国外代理服务器绕过国内封锁，故称为“翻墙”。（2）提高访问速度通常代理服务器可以缓存用户访问过的内容，当其他用户再访问相同的URL时，由代理服务器直接从缓存中找到要访问的信息，传给用户，已提高访问速度。例如，在企业内网部署一个Web代理服务器，能节省上网带宽。（3）隐藏真实IP上网者也可以通过这种方法隐藏自己的IP。有些网站的论坛会记录发帖人的IP地址。如果你不打算让论坛记录你真是的IP地址，就可以使用代理服务器访问该网站，发帖，这样只会记录下代理的地址，从而隐藏自己的IP地址。 国内外有很多免费的代理服务器，例如西刺免费代理。上面可以看到免费的代理服务器，在浏览器中设置使用这些代理服务器访问Internet。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/tags/网络基础/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"超文本协议","slug":"超文本协议","permalink":"http://yoursite.com/tags/超文本协议/"}]},{"title":"注册与登录","slug":"注册与登录","date":"2017-12-21T13:15:56.000Z","updated":"2017-12-30T12:24:12.991Z","comments":true,"path":"2017/12/21/注册与登录/","link":"","permalink":"http://yoursite.com/2017/12/21/注册与登录/","excerpt":"","text":"rails 中的gem devise提供了注册与登录的功能，用起来比较方便。但是为了自身编程能力，决定学习如何自写出注册与登录功能。 注册功能用户注册即创建一个用户，这时会用到我们所熟知的CRUD。理解起来很容易，但是做起来并没有那么简单。 首先需要生成user的model，并对其字段进行约束，通常情况下，会是name与email，例如name与email都不为空、长度、格式，为邮箱加索引等，把这些设置好之后，需要设置路由，控制器，还有视图。 Model约束字段。例如name与email的长度、格式、不为空，密码长度等，且为邮箱加索引。 routes.rb设置注册路由，一般会是get &#39;/signup&#39;, to: &#39;users#new&#39; post &#39;/signup&#39;, to: &#39;users#create&#39; Views设置注册表单。其中会用到form_for或者 simple_form_for Controllers编写users#new与 users#create 验证用户验证用户会用密码，因为我们会为user增加一个字段名称password_digest，在user的model中，添加has_secure_password这个方法（因为has_secure_password这个方法调用唯一要求就是对应的model中有password_digest 字段），它有三个作用: (1) 在数据库层中的password_digest中存储安全的密码哈希值（2）获得一对虚拟属性，password password_confirmation,而且创建对象时会执行存在性验证和匹配验证（3）获得authenticate方法，如果密码正确，返回用户对象，如果密码错误，返回false。 要想生成不可逆的密码哈希值，我们需要用到gem &#39;bcrypt&#39;,它的作用就是生成哈希密码值。这样即使‘脱库’，用户的真实密码也不会丢失。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"用户系统","slug":"用户系统","permalink":"http://yoursite.com/tags/用户系统/"}]},{"title":"部分gem总结","slug":"部分gem总结","date":"2017-09-06T17:54:55.000Z","updated":"2018-02-02T04:45:27.453Z","comments":true,"path":"2017/09/07/部分gem总结/","link":"","permalink":"http://yoursite.com/2017/09/07/部分gem总结/","excerpt":"","text":"1.gem ‘devise’ ———————————— 登录系统 安装须知： 依次执行bundle install rails g devise:install rails g devise user rake db:migrate，最后重新rails s。 2.gem ‘bootstrap-sass’ ———————————— 前端开发套件 安装须知：(1) 依次执行bundle install mv app/assets/stylesheets/application.css app/assets/stylesheets/application.scss;(2) app/assets/stylesheets/application.scss123+@import \"bootstrap-sprockets\";+@import \"bootstrap\"; 最后重新rails s 3.gem ‘simple_form’ ———————————— 简化表单 安装须知： 依次执行bundle install rails g simple_form:install --bootstrap,最后重新rails s 4.gem ‘font-awesome-rails’ ———————————— 图标套件 安装须知 （1）bundle install ,重新rails s（2） app/assets/stylesheets/application.scss1@import \"font-awesome\"; 5.gem ‘better_errors’ ———————————— 更好的显示错误讯息 安装须知 bundle install 重启rails s 6.gem ‘annotate’ ———————————— 在主要用于model中显示栏位 安装须知 bundle install 重启rails s执行annotate --exclude tests,fixtures,factories,serializers,ps：每次新增栏位后，都要执行这个命令，才会在具体model里显示出所有建立的栏位提示。 7.gem ‘awesome_rails_console’ —————————- 让“金手指”变好看的套件 安装须知 bundle install 重启rails s 8.gem ‘carrier_wave’ gem ‘mini_magick’ ———————————— 用于上传图片（可能还有其他的功能） 安装须知 依次执行：bundle install rails g uploader image 重启rails s","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"Gem","slug":"Gem","permalink":"http://yoursite.com/tags/Gem/"}]},{"title":"两种方法实现收藏或者点赞功能","slug":"两种方法实现收藏或者点赞功能","date":"2017-09-06T16:30:24.000Z","updated":"2018-01-02T14:24:18.694Z","comments":true,"path":"2017/09/07/两种方法实现收藏或者点赞功能/","link":"","permalink":"http://yoursite.com/2017/09/07/两种方法实现收藏或者点赞功能/","excerpt":"","text":"收藏功能与点赞功能的实作十分类似，本文以购物车教程实作收藏功能为例。 方法一：step1一个用户可以收藏多个商品，一个商品可以被收藏很多次，因此这是多对多的关系。因此需要新增一个model，来当做product与suer的桥梁。$ rails g model collect user_id:integer product_id:integer,然后执行 rake db:migrate，然后为collect、user与product这三个model加上关联。 app/models/collect.rb123456789 + belongs_to :user + belongs_to :product``` ``` ruby app/models/product.rb + has_many :collects + has_many :collected_users, through: :collects, source: :user app/models/user.rb1234567891011121314151617181920 + has_many :collects + has_many :collected_products, through: :collects, source: :product #加上是否收藏商品的判定 + def is_collect_of?(product) + collected_products.include?(product) + end``` #### step2首先修改路由信息：``` ruby config/routes.rb + resources :product do + member do + post :collect + post :uncollect + end + end 在controller里加上对应的method， app/controllers/product_controllers.rb1234567891011121314+ def collect + @product = Product.find(params[:id]) + current_user.collected_products &lt;&lt; @product + flash[:notice] = \"成功收藏商品\" + redirect_to :back+ end+ def uncollect + @product = Product.find(params[:id]) + currrent_user.collected_products.delete(@product) + flash[:warning] = \"您已取消收藏该商品\" + redirect_to :back+ end step3在views中的相应位置加入收藏的显示 app/views/products/show.html.erb123456+ &lt;% if current_user &amp;&amp; current_user.is_collect_of?(@product) %&gt;+ &lt;%= link_to(“取消收藏”, uncollect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\" )%&gt;+ &lt;% else %&gt;+ &lt;%= link_to(\"收藏“, collect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\" )%&gt;+ &lt;% end %&gt; 方法二step1同样，终端执行 rails g model colloect, 编辑 db/migrate/XXXXXXXX_create_collects.rbdb/migrate/XXXXXXXX_create_collects.rb 123456789 class CreateCollects &lt; ActiveRecord::Migration[5.0] def change create_table :collects do |t|+ t.integer :user_id, :index =&gt; true+ t.integer :product_id, :index =&gt; true t.timestamps end end end 之后执行 rake db:migrate 编辑app/models/collect.rb,加上关联app/models/collect.rb12+ belongs_to :user+ belongs_to :product 编辑 app/models/product.rb,加上关联app/models/product.rb123456789101112 + has_many :collects, :dependent =&gt; :destroy + had_many :collected_users, through: :collects, source: :user + def find_collect(user) + self.collects.where( :user_id =&gt; user.id).first + end``` 编辑 `app/model/user.rb`,加上关联``` ruby app/models/user.rb + has_many :collects, :dependent =&gt; :destroy + has_many :collected_products, through: :collects, source: :product step2编辑路由信息config/routes.rb123456+ resource :products do+ member do+ post :collect+ post :uncollect+ end+ end 在controller中添加：app/controllers/product_controller.rb12345678910111213141516+ def collect + @product = Product.find(params[:id]) + unless @product.find_collect(cuurent_user) + Collect.create( :user =&gt; current_user, :product =&gt; @product) + flash[:notice] = \"您已成功收藏该商品\" + end + redirect_to :back+ end+ def uncollect + @product = Product.find(params[:id]) + collect = @product.find_collect(current_user) + collect.destroy + flash[:warning] = \"您已取消收藏该商品\" + redirect_to :back+ end Step3最后一歩，就是要在 app/views/products/show.html.erb中加上收藏的按钮 app/views/products/show.html.erb123456789……略 + &lt;% if current_user %&gt; + &lt;% if @product.find_collect(current_user)%&gt; + &lt;% =link_to(\"取消收藏\", uncollect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\")%&gt; + &lt;% else %&gt; + &lt;%= link_to(\"收藏\", collect_product_path(@product), :method =&gt; :post, class: \"btn btn-primary btn-lg\")%&gt; + &lt;% end %&gt; + &lt;% end %&gt;……略 成果展示","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"}]},{"title":"利用ransack做搜索功能","slug":"利用ransack做搜索功能","date":"2017-09-06T16:27:42.000Z","updated":"2017-12-30T15:30:27.831Z","comments":true,"path":"2017/09/07/利用ransack做搜索功能/","link":"","permalink":"http://yoursite.com/2017/09/07/利用ransack做搜索功能/","excerpt":"","text":"本篇教程基于自己的一个小项目，用户可以搜索网站上其他用户发表过的文章。 第一歩：安装gem ransack ransack会用数据库的LIKE语法来做搜寻，虽然比较方便，但它会依次检查资料是否符合，而不会使用数据库的索引。如果数据比较庞大的话，利用ransack将不会是一个好的选择。这时候我们就可以安装专门的全文搜索引擎，例如Elasticsearch Gemfile1+ gem 'ransack' $ bundle，重启 rails s 第二歩controller与config的设定 1、设置路由config/routes.rb1234567891011121314151617181920212223242526272829303132333435 Rails.application.routes.draw do devise_for :users resources :posts do + collection do #我们会搜索出所有符合关键字的文章，结果为复数，因此用collection，而不是member + get :search + end end end ``` #### 2、设置controller主要设置通过哪些关键词进行搜索。```ruby app/controllers/posts_controller.rb class PostsController &lt; ApplicationController before_action :validate_search_key, only: [:search] def search if @query_string.present? @posts = search_params #搜索post的关键词 end end protected # 放在最后 def validate_search_key # gsub 是Ruby中正则表达式的方法，它会切换所有匹配到的部分 @query_string = params[:q].gsub(/\\\\|\\'|\\/|\\?/, \"\")if params[:q].present? end def search_params Post.ransack(&#123;:title_or_content_cont =&gt; @query_string&#125;).result(distinct: true) #title与content是post的两个栏位，而我们的关键词出自这里 end end 第三歩views的设定 1、导航栏的显示app/views/common/_navbar.html.erb12345678910 &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; + &lt;ul class=\"nav navbar-nav\"&gt; + &lt;li&gt; + &lt;div class=\"form-group form-inline search-bar\"&gt; + &lt;%= render :partial =&gt; \"posts/search_bar\"%&gt; + &lt;/div&gt; + &lt;/li&gt; + &lt;/ul&gt; …… 略&lt;/div&gt; 执行$ touch app/views/posts/_search_bar.html.erb,并编辑app/views/posts/_search_bar.html.erb1234567891011121314 &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-9 col-lg-8 col-lg-offset-2\"&gt; &lt;%= form_tag search_posts_path, :class =&gt; \"posts-search-form\", :method =&gt; :get do %&gt; &lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control search-bar-input\" name=\"q\" value=\"&lt;%= params[:q] %&gt;\" placeholder=\"关键词\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button type=\"submit\" class=\"btn btn-default search-bar-submit\"&gt; &lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/div&gt; 2.搜索反馈页面新增 app/views/posts/search.html.erbapp/views/posts/search.html.erb123456789101112131415161718192021222324252627282930313233&lt;div class=\"minHeight1000 bg-gray\"&gt; &lt;div class=\"search-page w1200 pt30 bc\"&gt; &lt;% if @posts.present? %&gt; &lt;h5 class=\"collection search-count\"&gt;已为您找到&lt;%= @posts.count %&gt;篇相关文章&lt;/h5&gt; &lt;% else %&gt; &lt;p class=\"tc mt100\"&gt;未搜索到任何文章，要不换个关键词试试？&lt;/p&gt; &lt;% end %&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;% @posts.each do |post| %&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;%= post.title %&gt; &lt;br/&gt; &lt;br/&gt; &lt;span id=\"psot-thumbsup-&lt;%= post.id%&gt;\" class=\" label label-success\"&gt;&lt;%= post.likes.count%&gt;👍&lt;/span&gt; &lt;div class=\"text-right\"&gt; &lt;% if !current_user.is_collect_of?(post) %&gt; &lt;%= link_to(\"收藏\", collect_post_path(post), method: :post, class: \"btn btn-sm\") %&gt; &lt;% else %&gt; &lt;%= link_to(\"取消收藏\", uncollect_post_path(post), method: :post, class: \"btn btn-sm\") %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/div&gt; 效果图","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"ransack","slug":"ransack","permalink":"http://yoursite.com/tags/ransack/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-06T09:33:31.000Z","updated":"2017-09-06T09:33:31.000Z","comments":true,"path":"2017/09/06/hello-world/","link":"","permalink":"http://yoursite.com/2017/09/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}