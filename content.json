{"meta":{"title":"jonathan-fei.pro","subtitle":null,"description":"Stay hungry. Stay foolish.","author":"jonathan-fei","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-12-30T12:23:01.000Z","updated":"2017-12-30T12:23:14.179Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-30T12:21:04.000Z","updated":"2017-12-30T12:21:51.399Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库的事务与锁","slug":"数据库的事务与锁","date":"2018-01-03T07:15:58.000Z","updated":"2018-01-03T07:39:57.375Z","comments":true,"path":"2018/01/03/数据库的事务与锁/","link":"","permalink":"http://yoursite.com/2018/01/03/数据库的事务与锁/","excerpt":"","text":"学习数据库的事务与锁之前需要先了解下什么是并发： 多个用户对同一数据进行交互叫做并发。如果不加以控制，并发可能引起很多问题。数据库提供了可以合理解决并发问题的方案。 一、事务 事务的概念：类比于银行转账，A转给B100元，那么A的账户减少500，B的账户增加500元，这个两个操作必须全部执行，要么就全部不执行。数据库的的事务总是将指定的一条语句或多条语句看成一个全部执行或者全部不执行的最小组合全部组合。 事务类型：如SELECT INSERT UPDATE DELETE 1- 显示事务处理模式通过START TRANSACTION 标记事务起始点，如果开启事务后执行的语句是按照期望正确执行的则以COMMIT TRANSACTION 来结束事务；如果开始事务后执行的语句结果不是所期望的，并希望取消刚才的操作，则以ROLLBACK TRANSATION 来结束事务，（相当于撤销），该动作成为回滚。前滚指的是再次执行一次事务中的操作。 2- 自动提交事务模式默认情况下，MySQL是自动提交的。在该模式下，每条语句都被认为是一个事务。当每个SQL语句执行完成后，不是被提交就是被回滚，如果执行成功则提交，执行失败则回滚。注意：在该模式下，执行的语句如果出现编译错误（例如关键字错误）而非运行错误该批语句都不会执行，而不是执行后再回滚；如果是运行错误不会导致该批语句都不执行，而是错误语句会回滚，之前语句正常执行。 3-隐式事务处理模式可以通过 SET IMPLICIT_TRANSACTIONS ON 和 SET IMPLICIT_TRANSACTIONS OFF 来启动和关闭隐式模式。与显示事务处理模式相比，它省略了事务起始点，也就是START TRANSATION。 PS:事务也是可以嵌套的，这里不进行详细说明。 二、并发访问引起的问题并发：两个用户或者两个以上的用户在同一时间与同一对象进行交互。例如春节抢票，抢的人越多，并发数就越高，对系统性能要求就越高。 1- 丢失更新当两个或多个事务对同一数据最初的值进行更新时，由于每个事务都不知道其他事务的存在，最后提交的事务中的更新操作就会覆盖掉其他事务所做的更新，这就导致其他事务的更新操作丢失。 2- 脏读事务完成数据更新后，这时其他事务去查询该行数据的时候读取的数据是临时的，如果最后更新的事务被回滚，这个临时数据对于查询的事务来说就是“脏数据”。 3- 不可重复读在一个事务两次的查询之间，同一数据被其他事务更新，导致同一事务中的两次查询结果不同，这样的现象叫做不可重复读。确定的某条记录。 4- 幻影读一个事务中指定范围的两次查询结果因为其他事务更新了符合范围的数据，导致两次结果查询结果不同，这样的现象叫做幻影读。幻影读不仅仅只适用于符合条件的范围内的记录有多少，还适用于涉及到范围概念的情况。与范围数据有关。 三、锁锁，即锁定，在数据库的概念为：在哪些数据或者对象上获取了锁就对对应的数据或者对象进行了锁定，其他事务就无法获取和现有锁相冲突的锁。锁是事务用来保护与自己交互的数据或者对象不受其他事务干扰的机制，实现了事务与事务之间的隔离。正是因为锁的存在，才可以根据业务需求合理地解决并发访问带来的问题。 1- 锁的粒度与锁升级数据库可以在某一行获取锁，也可以对某一张表获取锁，也可以对整个数据库获取锁。这种多层次的锁结构成为锁的粒度。锁的粒度越粗，并发度越低，系统性能越高。下面可以申请锁的粒度类型： 行或行标识符（RID）：属于行级锁（InnoDB），用于锁定堆中某个行的行标识符。 键（Key）：属于行级锁，在索引的键上存放锁，用户保护事务中的键的范围。 页（Page）：锁定该页中的所有数据或键。 区（Excent）：锁定整个区段，包括里面的页以及页中的数据行和键。 表（Table）：锁定整个表以及与表关联的所有对象，如表中的数据行、索引键。 数据库（Database）：锁定整个数据库。 由低层次的锁升级到高层次的锁成为锁升级。 2- 锁的类型数据库引擎基于事务类型选择不同的锁，这些锁决定了并发事件访问资源的方式。此处只列出三种类型的锁。 （1）共享锁（S锁）共享锁用于只需要读取不需要进行修改或更新数据的操作，如SELECT语句就是一种最基本常见的申请共享锁的语句。共享锁避免了不可重复读与幻影读问题。 （2）独占锁（X锁）独占锁也成为排他锁。与其他所有的锁都冲突。当需要进行数据更改操作如INSERT、UPDATE、DELETE时，锁管理器就会分配X锁。一般情况下，数据修改时包含两个动作：读取需要的数据和修改数据，因此在数据修改时会申请共享锁和独占锁。在同一张表中修改数据，此时共享锁更应该成为更新锁，但是如果更新操作连接了其他表，那么其他表中就会存在共享锁，并在需要的数据上申请独占锁。 （3）更新锁（U锁）更新锁和共享锁兼容，和独占锁冲突。更新锁和更新锁也冲突。修改数据时会先申请更新锁后申请独占锁， 更新锁是一种过渡锁。在进行数据搜索时持有了更新锁，由于更新锁和共享锁兼容，因此此时其他事务是允许读取数据的，当确定修改数据后，更新锁等待其他事务的共享锁释放后就会转换为独占锁（那么等待时间如何计算？），并将其他事务的相关资源的锁申请全部队列化堵在数据修改的进程外，直到独占锁释放，其他事务才能进行相关资源的申请。 死锁：两个事务都在等待一个资源，但同时又相互阻止对方获取资源，这时就会发生死锁现象。例如，事务A和事务B都获取了某一行数据的共享锁（也就是可以查看该数据），当事务A想修改该数据时要将共享锁转化为独占锁，这就需要等待事务B释放共享锁，但是事务B也想修改数据，将共享锁转换为独占锁，它将等待事务A释放共享锁，这样两个事务之间形成了僵局。 更新锁和共享锁是兼容的，因此更新锁和共享锁可能在同一资源上相互共存，但是更新锁和更新锁是相互冲突的，所以只能有一个事务对数据有更新锁。在过度为独占锁前，只有更新锁的事务必须先等待其他事务释放所有的共享锁，这就避免了上述的死锁问题。 四、事务隔离级别在数据库系统中可以通过设置事务隔离级别间接地控制锁，实现事务之间的隔离，从而解决并发问题。事务隔离级别是并发控制的整体解决方案，其实质是通过控制锁来控制事务之间如何进行隔离。 1- 提交读（READ COMMITTED）查询申请的共享锁在语句执行完毕后就释放，不需要等待事务结束后释放；数据修改申请的独占锁一直持有，直到事务结束才释放。设置提交读，可以避免脏读问题，但是不能解决不可重复读和幻影读。 PS：设置事务隔离级别和查看。隔离级别的设置是对会话级别的，所以只对当前会话有效。 2- 可提交读（READ UNCOMMITTED）未提交读是控制级别最低的级别，设置之后，该会话的所有读操作将不申请共享锁，因此读时将忽略所有的锁，但是更新时仍然会申请独占锁，这种情况下并发带来的问题都有可能发生。 3- 可重复读（REPEATABLE READ）MySQL默认事务隔离级别，当设置为可重复读隔离级别时，除了独占锁会一直保持到事务结束，共享锁也一样到事务结束。可重复读隔离级别下，脏读、丢失的更新和不可重复读问题都能够避免，但是也因为共享锁一直持有，会导致其他事务不能对相关数据进行修改，降低了并发度和性能。可重复读隔离级别无法解决幻影读问题。 4- 串行化（SERIALIZABLE）串行化隔离级别隔离层次最高，它能够避免丢失的更新、脏读、不可重复读和幻影读问题。设置为串行化隔离级别后，共享锁也将一直持有到事务结束。比可重复读更严格的是它的锁定是范围的，还包括潜在的数据修改。它保证了范围内两次查询结果不会出现增加记录或减少记录而出现幻象。 串行化隔离级别对锁控制的方式为：如果在查询指定条件的列上有索引，则在该列符合条件的范围记录上加上KEY粒度的锁，如果在查询条件的列上没有索引，则直接在表上加上共享锁。 五、隔离级别、锁和并发问题的关系","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"},{"name":"数据库事务","slug":"数据库事务","permalink":"http://yoursite.com/tags/数据库事务/"},{"name":"数据库的锁","slug":"数据库的锁","permalink":"http://yoursite.com/tags/数据库的锁/"}]},{"title":"网络基础-HTTP","slug":"网络基础-HTTP","date":"2018-01-02T14:25:13.000Z","updated":"2018-01-02T15:10:39.828Z","comments":true,"path":"2018/01/02/网络基础-HTTP/","link":"","permalink":"http://yoursite.com/2018/01/02/网络基础-HTTP/","excerpt":"","text":"最近Rails项目部署的过程中遇到网络端口的问题及用到了http网络协议的知识，于是决定对这块知识进行回顾和重新梳理，这里推荐韩立刚老师的《计算机网络原理》一书，讲的很明白。以下为这次学习到的主要内容： HTTP( Hyper Text Transfer Protocol) WWW( World Wide Web),互联网上的网站共同组成万维网。 URL( Uniform Resource Locator)，统一资源定位符，网站的网址。URL一般由四个部分组成：&lt;协议&gt;://&lt;主机&gt;:&lt;/端口&gt;/&lt;路径&gt;，例如http://106.14.190.181:80/wx 一、HTTP协议版本：1- HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，既不跟踪每个客户也不记录过去的请求。 2- HTTP1.1支持持续连接，即服务器在发送响应后，仍然在一段时间内保持这条TCP连接，使得同一个浏览器和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。HTTP1.1的持续连接有两种工作方式，即非流水线方式和流水线方式。非流水线方式（理解为迅雷一次只能下载一个文件）的特点是客户在收到前一个响应后才能发送写一个请求。因此，在TCP连接建立后，客户每访问一次对象都要用去一个往返时间RTT，这种方式浪费服务器资源。流水线的特点（理解为迅雷一次可以下载多个文件）是客户在收到HTTP响应报文之前就能够发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文，这种方式使TCP连接中的空闲时间减少，提高了文档的下载效率。 3- HTTP请求报文与响应报文（1） 请求报文：从客户端向服务器发送请求报文 请求报文由三个部分组成：分别是请求行，首部行，实体主体。请求报文的第一行“请求行”只有三个内容，即方法、请求资源的URL，以及HTTP的版本。方法就是对对象的操作，HTTP1.1协议中定义了八中方法，来表明对Request-URL指定资源的不同操作方式：GET、POST、PUT、DELETE、HEAD、TRACE、CONNECT、OPPIONS（2）响应报文：从服务器到达客户端的应答 二、CookieHTTP是一种无状态的协议，当你注册登录一个网站后，当下次再打开这个网站后，需要再次输入账号与密码进行身份验证，服务器仅从网络连接上无从知道你的曾经登录的身份。如果希望服务器读取你的曾经登录的身份，那就需要在用户输入账号和密码后，服务器在用户的计算机存放一个通行证，来记录用户的身份和状态。以后再访问，网站（服务器）就会先读取客户端的通行证。服务器存放在客户端（浏览器）的通行证通常被称为cookie。 cookie实际上是一小段的文本信息（说明可以进行拷贝，也就是在其他浏览器导入cookie之后不用输入账号和密码就可以登录了）。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端把浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器吧请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份和状态。服务器还可以根据需要修改cookie的内容。 三、通过代理服务器访问网站代理服务器英文全称为Proxy Server，其功能就是代理网络用户去取得网络信息。我们可以配置计算机通过Web代理服务器访问Web站点，而不直接访问网站。 使用代理服务器的场景：（1）使用代理服务器，绕过防火墙封锁。国内不允许网民访问国外的非法网站，在我国的防火墙上设置了拦截到这些网站的流量。但是国外有很多的web代理服务器，国内用户可以设置浏览器使用国外的代理商服务器，然后访问非法网站，就能成功。现在有很多“翻墙”软件，其实质就是使用国外代理服务器绕过国内封锁，故称为“翻墙”。（2）提高访问速度通常代理服务器可以缓存用户访问过的内容，当其他用户再访问相同的URL时，由代理服务器直接从缓存中找到要访问的信息，传给用户，已提高访问速度。例如，在企业内网部署一个Web代理服务器，能节省上网带宽。（3）隐藏真实IP上网者也可以通过这种方法隐藏自己的IP。有些网站的论坛会记录发帖人的IP地址。如果你不打算让论坛记录你真是的IP地址，就可以使用代理服务器访问该网站，发帖，这样只会记录下代理的地址，从而隐藏自己的IP地址。 国内外有很多免费的代理服务器，例如西刺免费代理。上面可以看到免费的代理服务器，在浏览器中设置使用这些代理服务器访问Internet。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/categories/网络基础/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"http://yoursite.com/tags/网络基础/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"超文本协议","slug":"超文本协议","permalink":"http://yoursite.com/tags/超文本协议/"}]},{"title":"注册与登录","slug":"注册与登录","date":"2017-12-21T13:15:56.000Z","updated":"2017-12-30T12:24:12.991Z","comments":true,"path":"2017/12/21/注册与登录/","link":"","permalink":"http://yoursite.com/2017/12/21/注册与登录/","excerpt":"","text":"rails 中的gem devise提供了注册与登录的功能，用起来比较方便。但是为了自身编程能力，决定学习如何自写出注册与登录功能。 注册功能用户注册即创建一个用户，这时会用到我们所熟知的CRUD。理解起来很容易，但是做起来并没有那么简单。 首先需要生成user的model，并对其字段进行约束，通常情况下，会是name与email，例如name与email都不为空、长度、格式，为邮箱加索引等，把这些设置好之后，需要设置路由，控制器，还有视图。 Model约束字段。例如name与email的长度、格式、不为空，密码长度等，且为邮箱加索引。 routes.rb设置注册路由，一般会是get &#39;/signup&#39;, to: &#39;users#new&#39; post &#39;/signup&#39;, to: &#39;users#create&#39; Views设置注册表单。其中会用到form_for或者 simple_form_for Controllers编写users#new与 users#create 验证用户验证用户会用密码，因为我们会为user增加一个字段名称password_digest，在user的model中，添加has_secure_password这个方法（因为has_secure_password这个方法调用唯一要求就是对应的model中有password_digest 字段），它有三个作用: (1) 在数据库层中的password_digest中存储安全的密码哈希值（2）获得一对虚拟属性，password password_confirmation,而且创建对象时会执行存在性验证和匹配验证（3）获得authenticate方法，如果密码正确，返回用户对象，如果密码错误，返回false。 要想生成不可逆的密码哈希值，我们需要用到gem &#39;bcrypt&#39;,它的作用就是生成哈希密码值。这样即使‘脱库’，用户的真实密码也不会丢失。","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"用户系统","slug":"用户系统","permalink":"http://yoursite.com/tags/用户系统/"}]},{"title":"部分gem总结","slug":"部分gem总结","date":"2017-09-06T17:54:55.000Z","updated":"2018-01-02T15:14:07.363Z","comments":true,"path":"2017/09/07/部分gem总结/","link":"","permalink":"http://yoursite.com/2017/09/07/部分gem总结/","excerpt":"","text":"1.gem ‘devise’ ———————————— 登录系统 安装须知： 依次执行bundle install rails g devise:install rails g devise user rake db:migrate，最后重新rails s。 2.gem ‘bootstrap’ ———————————— 前端开发套件 安装须知：(1) 依次执行bundle install mv app/assets/stylesheets/application.css app/assets/stylesheets/application.scss;(2) app/assets/stylesheets/application.scss123+@import \"bootstrap-sprockets\";+@import \"bootstrap\"; 最后重新rails s 3.gem ‘simple_form’ ———————————— 简化表单 安装须知： 依次执行bundle install rails g simple_form:install --bootstrap,最后重新rails s 4.gem ‘font-awesome-rails’ ———————————— 图标套件 安装须知 （1）bundle install ,重新rails s（2） app/assets/stylesheets/application.scss1@import \"font-awesome\"; 5.gem ‘better_errors’ ———————————— 更好的显示错误讯息 安装须知 bundle install 重启rails s 6.gem ‘annotate’ ———————————— 在主要用于model中显示栏位 安装须知 bundle install 重启rails s执行annotate --exclude tests,fixtures,factories,serializers,ps：每次新增栏位后，都要执行这个命令，才会在具体model里显示出所有建立的栏位提示。 7.gem ‘awesome_rails_console’ —————————- 让“金手指”变好看的套件 安装须知 bundle install 重启rails s 8.gem ‘carrier_wave’ gem ‘mini_magick’ ———————————— 用于上传图片（可能还有其他的功能） 安装须知 依次执行：bundle install rails g uploader image 重启rails s","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"Gem","slug":"Gem","permalink":"http://yoursite.com/tags/Gem/"}]},{"title":"两种方法实现收藏或者点赞功能","slug":"两种方法实现收藏或者点赞功能","date":"2017-09-06T16:30:24.000Z","updated":"2018-01-02T14:24:18.694Z","comments":true,"path":"2017/09/07/两种方法实现收藏或者点赞功能/","link":"","permalink":"http://yoursite.com/2017/09/07/两种方法实现收藏或者点赞功能/","excerpt":"","text":"收藏功能与点赞功能的实作十分类似，本文以购物车教程实作收藏功能为例。 方法一：step1一个用户可以收藏多个商品，一个商品可以被收藏很多次，因此这是多对多的关系。因此需要新增一个model，来当做product与suer的桥梁。$ rails g model collect user_id:integer product_id:integer,然后执行 rake db:migrate，然后为collect、user与product这三个model加上关联。 app/models/collect.rb123456789 + belongs_to :user + belongs_to :product``` ``` ruby app/models/product.rb + has_many :collects + has_many :collected_users, through: :collects, source: :user app/models/user.rb1234567891011121314151617181920 + has_many :collects + has_many :collected_products, through: :collects, source: :product #加上是否收藏商品的判定 + def is_collect_of?(product) + collected_products.include?(product) + end``` #### step2首先修改路由信息：``` ruby config/routes.rb + resources :product do + member do + post :collect + post :uncollect + end + end 在controller里加上对应的method， app/controllers/product_controllers.rb1234567891011121314+ def collect + @product = Product.find(params[:id]) + current_user.collected_products &lt;&lt; @product + flash[:notice] = \"成功收藏商品\" + redirect_to :back+ end+ def uncollect + @product = Product.find(params[:id]) + currrent_user.collected_products.delete(@product) + flash[:warning] = \"您已取消收藏该商品\" + redirect_to :back+ end step3在views中的相应位置加入收藏的显示 app/views/products/show.html.erb123456+ &lt;% if current_user &amp;&amp; current_user.is_collect_of?(@product) %&gt;+ &lt;%= link_to(“取消收藏”, uncollect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\" )%&gt;+ &lt;% else %&gt;+ &lt;%= link_to(\"收藏“, collect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\" )%&gt;+ &lt;% end %&gt; 方法二step1同样，终端执行 rails g model colloect, 编辑 db/migrate/XXXXXXXX_create_collects.rbdb/migrate/XXXXXXXX_create_collects.rb 123456789 class CreateCollects &lt; ActiveRecord::Migration[5.0] def change create_table :collects do |t|+ t.integer :user_id, :index =&gt; true+ t.integer :product_id, :index =&gt; true t.timestamps end end end 之后执行 rake db:migrate 编辑app/models/collect.rb,加上关联app/models/collect.rb12+ belongs_to :user+ belongs_to :product 编辑 app/models/product.rb,加上关联app/models/product.rb123456789101112 + has_many :collects, :dependent =&gt; :destroy + had_many :collected_users, through: :collects, source: :user + def find_collect(user) + self.collects.where( :user_id =&gt; user.id).first + end``` 编辑 `app/model/user.rb`,加上关联``` ruby app/models/user.rb + has_many :collects, :dependent =&gt; :destroy + has_many :collected_products, through: :collects, source: :product step2编辑路由信息config/routes.rb123456+ resource :products do+ member do+ post :collect+ post :uncollect+ end+ end 在controller中添加：app/controllers/product_controller.rb12345678910111213141516+ def collect + @product = Product.find(params[:id]) + unless @product.find_collect(cuurent_user) + Collect.create( :user =&gt; current_user, :product =&gt; @product) + flash[:notice] = \"您已成功收藏该商品\" + end + redirect_to :back+ end+ def uncollect + @product = Product.find(params[:id]) + collect = @product.find_collect(current_user) + collect.destroy + flash[:warning] = \"您已取消收藏该商品\" + redirect_to :back+ end Step3最后一歩，就是要在 app/views/products/show.html.erb中加上收藏的按钮 app/views/products/show.html.erb123456789……略 + &lt;% if current_user %&gt; + &lt;% if @product.find_collect(current_user)%&gt; + &lt;% =link_to(\"取消收藏\", uncollect_product_path(@product), :method =&gt; :post, class: \"btn btn-danger btn-lg\")%&gt; + &lt;% else %&gt; + &lt;%= link_to(\"收藏\", collect_product_path(@product), :method =&gt; :post, class: \"btn btn-primary btn-lg\")%&gt; + &lt;% end %&gt; + &lt;% end %&gt;……略 成果展示","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"}]},{"title":"利用ransack做搜索功能","slug":"利用ransack做搜索功能","date":"2017-09-06T16:27:42.000Z","updated":"2017-12-30T15:30:27.831Z","comments":true,"path":"2017/09/07/利用ransack做搜索功能/","link":"","permalink":"http://yoursite.com/2017/09/07/利用ransack做搜索功能/","excerpt":"","text":"本篇教程基于自己的一个小项目，用户可以搜索网站上其他用户发表过的文章。 第一歩：安装gem ransack ransack会用数据库的LIKE语法来做搜寻，虽然比较方便，但它会依次检查资料是否符合，而不会使用数据库的索引。如果数据比较庞大的话，利用ransack将不会是一个好的选择。这时候我们就可以安装专门的全文搜索引擎，例如Elasticsearch Gemfile1+ gem 'ransack' $ bundle，重启 rails s 第二歩controller与config的设定 1、设置路由config/routes.rb1234567891011121314151617181920212223242526272829303132333435 Rails.application.routes.draw do devise_for :users resources :posts do + collection do #我们会搜索出所有符合关键字的文章，结果为复数，因此用collection，而不是member + get :search + end end end ``` #### 2、设置controller主要设置通过哪些关键词进行搜索。```ruby app/controllers/posts_controller.rb class PostsController &lt; ApplicationController before_action :validate_search_key, only: [:search] def search if @query_string.present? @posts = search_params #搜索post的关键词 end end protected # 放在最后 def validate_search_key # gsub 是Ruby中正则表达式的方法，它会切换所有匹配到的部分 @query_string = params[:q].gsub(/\\\\|\\'|\\/|\\?/, \"\")if params[:q].present? end def search_params Post.ransack(&#123;:title_or_content_cont =&gt; @query_string&#125;).result(distinct: true) #title与content是post的两个栏位，而我们的关键词出自这里 end end 第三歩views的设定 1、导航栏的显示app/views/common/_navbar.html.erb12345678910 &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; + &lt;ul class=\"nav navbar-nav\"&gt; + &lt;li&gt; + &lt;div class=\"form-group form-inline search-bar\"&gt; + &lt;%= render :partial =&gt; \"posts/search_bar\"%&gt; + &lt;/div&gt; + &lt;/li&gt; + &lt;/ul&gt; …… 略&lt;/div&gt; 执行$ touch app/views/posts/_search_bar.html.erb,并编辑app/views/posts/_search_bar.html.erb1234567891011121314 &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-9 col-lg-8 col-lg-offset-2\"&gt; &lt;%= form_tag search_posts_path, :class =&gt; \"posts-search-form\", :method =&gt; :get do %&gt; &lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control search-bar-input\" name=\"q\" value=\"&lt;%= params[:q] %&gt;\" placeholder=\"关键词\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button type=\"submit\" class=\"btn btn-default search-bar-submit\"&gt; &lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/div&gt; 2.搜索反馈页面新增 app/views/posts/search.html.erbapp/views/posts/search.html.erb123456789101112131415161718192021222324252627282930313233&lt;div class=\"minHeight1000 bg-gray\"&gt; &lt;div class=\"search-page w1200 pt30 bc\"&gt; &lt;% if @posts.present? %&gt; &lt;h5 class=\"collection search-count\"&gt;已为您找到&lt;%= @posts.count %&gt;篇相关文章&lt;/h5&gt; &lt;% else %&gt; &lt;p class=\"tc mt100\"&gt;未搜索到任何文章，要不换个关键词试试？&lt;/p&gt; &lt;% end %&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;% @posts.each do |post| %&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; &lt;%= post.title %&gt; &lt;br/&gt; &lt;br/&gt; &lt;span id=\"psot-thumbsup-&lt;%= post.id%&gt;\" class=\" label label-success\"&gt;&lt;%= post.likes.count%&gt;👍&lt;/span&gt; &lt;div class=\"text-right\"&gt; &lt;% if !current_user.is_collect_of?(post) %&gt; &lt;%= link_to(\"收藏\", collect_post_path(post), method: :post, class: \"btn btn-sm\") %&gt; &lt;% else %&gt; &lt;%= link_to(\"取消收藏\", uncollect_post_path(post), method: :post, class: \"btn btn-sm\") %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt;&lt;/div&gt; 效果图","categories":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/categories/Ruby/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://yoursite.com/tags/Ruby/"},{"name":"ransack","slug":"ransack","permalink":"http://yoursite.com/tags/ransack/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-06T09:33:31.000Z","updated":"2017-09-06T09:33:31.000Z","comments":true,"path":"2017/09/06/hello-world/","link":"","permalink":"http://yoursite.com/2017/09/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}